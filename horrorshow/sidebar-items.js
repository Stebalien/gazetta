initSidebarItems({"macro":[["box_html!","Crate a new owned html template.This template will be boxed and will own it's environment. If you need to return a template from a function, use this.Example:"],["html!","Crate a new html template"],["raw!","Mark a string as a raw. The string will not be rendered."],["template!","Create a new template.This allows you to declare a template as follows:You can instantiate these templates by calling `new` on them:These templates never own their content, they just borrow it. This is one of the reasons I call this feature \"experimental\"."]],"mod":[["prelude","Traits that should always be imported."]],"struct":[["Error",""],["FnRenderer","A template renderer. The `html! {}` macro returns a `FnRenderer`."],["Raw","Raw content marker.When rendered, raw content will not be escaped."],["TemplateBuffer","A template buffer. This is the type that gets passed to closures inside templates.Example:"]],"trait":[["Render","Something that can be rendered by reference."],["RenderBox","Something that can be rendered once out of a box.This should only ever be used in the form `Box<RenderBox>` by casting `Box<RenderOnce>` to `Box<RenderBox>`. This trait has methods but I've hidden them because you should never call them directly.  Instead, you should call the `RenderOnce` methods implemented on `Box<RenderBox>`."],["RenderMut","Something that can be rendered by mutable reference."],["RenderOnce","Something that can be rendered once."],["Template","A template that can be rendered into something.Don't let the single impl below fool you, these methods are available on all `Render*`'s (through impls on references and boxes)."]]});