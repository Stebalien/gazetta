initSidebarItems({"constant":[["POST_DROP_U32",""],["POST_DROP_U64",""],["POST_DROP_U8",""],["POST_DROP_USIZE",""]],"fn":[["align_of","Returns the alignment in memory for a type.This is the alignment used for struct fields. It may be smaller than the preferred alignment.Examples"],["align_of_val","Returns the ABI-required minimum alignment of the type of the value that `val` points toExamples"],["drop","Disposes of a value.While this does call the argument's implementation of `Drop`, it will not release any borrows, as borrows are based on lexical scope.This effectively does nothing for types which implement `Copy`, e.g. integers. Such values are copied and _then_ moved into the function, so the value persists after this function call.ExamplesBasic usage:Borrows are based on lexical scope, so this produces an error:An inner scope is needed to fix this:Since `RefCell` enforces the borrow rules at runtime, `drop()` can seemingly release a borrow of one:Integers and other types implementing `Copy` are unaffected by `drop()`"],["dropped","Creates a value initialized to an unspecified series of bytes.The byte sequence usually indicates that the value at the memory in question has been dropped. Thus, *if* T carries a drop flag, any associated destructor will not be run when the value falls out of scope.Some code at one time used the `zeroed` function above to accomplish this goal.This function is expected to be deprecated with the transition to non-zeroing drop."],["forget","Leaks a value into the void, consuming ownership and never running its destructor.This function will take ownership of its argument, but is distinct from the `mem::drop` function in that it **does not run the destructor**, leaking the value and any resources that it owns.There's only a few reasons to use this function. They mainly come up in unsafe code or FFI code.You have an uninitialized value, perhaps for performance reasons, and need to prevent the destructor from running on it. You have two copies of a value (like when writing something like `mem::swap`), but need the destructor to only run once to prevent a double `free`. Transferring resources across FFI boundaries. SafetyThis function is not marked as `unsafe` as Rust does not guarantee that the `Drop` implementation for a value will always run. Note, however, that leaking resources such as memory or I/O objects is likely not desired, so this function is only recommended for specialized use cases.The safety of this function implies that when writing `unsafe` code yourself care must be taken when leveraging a destructor that is required to run to preserve memory safety. There are known situations where the destructor may not run (such as if ownership of the object with the destructor is returned) which must be taken into account.Other forms of LeakageIt's important to point out that this function is not the only method by which a value can be leaked in safe Rust code. Other known sources of leakage are:`Rc` and `Arc` cycles `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally) Panicking destructors are likely to leak local resources ExampleLeak some heap memory by never deallocating it:Leak an I/O object, never closing the file:The `mem::swap` function uses `mem::forget` to good effect:"],["min_align_of","Returns the ABI-required minimum alignment of a typeThis is the alignment used for struct fields. It may be smaller than the preferred alignment.Examples"],["min_align_of_val","Returns the ABI-required minimum alignment of the type of the value that `val` points toExamples"],["replace","Replaces the value at a mutable location with a new one, returning the old value, without deinitializing or copying either one.This is primarily used for transferring and swapping ownership of a value in a mutable location.ExamplesA simple example:This function allows consumption of one field of a struct by replacing it with another value. The normal approach doesn't always work:Note that `T` does not necessarily implement `Clone`, so it can't even clone and reset `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from `self`, allowing it to be returned:"],["size_of","Returns the size of a type in bytes.Examples"],["size_of_val","Returns the size of the given value in bytes.Examples"],["swap","Swap the values at two mutable locations of the same type, without deinitializing or copying either one.Examples"],["transmute","Unsafely transforms a value of one type into a value of another type.Both types must have the same size.Examples"],["transmute_copy","Interprets `src` as `&U`, and then reads `src` without moving the contained value.This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It will also unsafely create a copy of the contained value instead of moving out of `src`.It is not a compile-time error if `T` and `U` have different sizes, but it is highly encouraged to only invoke this function where `T` and `U` have the same size. This function triggers undefined behavior if `U` is larger than `T`.Examples"],["uninitialized","Bypasses Rust's normal memory-initialization checks by pretending to produce a value of type T, while doing nothing at all.**This is incredibly dangerous, and should not be done lightly. Deeply consider initializing your memory with a default value instead.**This is useful for FFI functions and initializing arrays sometimes, but should generally be avoided.Undefined BehaviorIt is Undefined Behavior to read uninitialized memory. Even just an uninitialized boolean. For instance, if you branch on the value of such a boolean your program may take one, both, or neither of the branches.Note that this often also includes *writing* to the uninitialized value. Rust believes the value is initialized, and will therefore try to Drop the uninitialized value and its fields if you try to overwrite the memory in a normal manner. The only way to safely initialize an arbitrary uninitialized value is with one of the `ptr` functions: `write`, `copy`, or `copy_nonoverlapping`. This isn't necessary if `T` is a primitive or otherwise only contains types that don't implement Drop.If this value *does* need some kind of Drop, it must be initialized before it goes out of scope (and therefore would be dropped). Note that this includes a `panic` occurring and unwinding the stack suddenly.ExamplesHere's how to safely initialize an array of `Vec`s.This example emphasizes exactly how delicate and dangerous doing this is. Note that the `vec!` macro *does* let you initialize every element with a value that is only `Clone`, so the following is semantically equivalent and vastly less dangerous, as long as you can live with an extra heap allocation:"],["zeroed","Creates a value initialized to zero.This function is similar to allocating space for a local variable and zeroing it out (an unsafe operation).Care must be taken when using this function, if the type `T` has a destructor and the value falls out of scope (due to unwinding or returning) before being initialized, then the destructor will run on zeroed data, likely leading to crashes.This is useful for FFI functions sometimes, but should generally be avoided.Examples"]]});