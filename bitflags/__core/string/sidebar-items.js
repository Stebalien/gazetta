initSidebarItems({"enum":[["ParseError","An error when parsing a `String`.This `enum` is slightly awkward: it will never actually exist. This error is part of the type signature of the implementation of `FromStr` on `String`. The return type of `from_str()`, requires that an error be defined, but, given that a `String` can always be made into a new `String` without error, this type will never actually be returned. As such, it is only here to satisfy said signature, and is useless otherwise."]],"struct":[["Drain","A draining iterator for `String`.This struct is created by the `drain()` method on `String`. See its documentation for more."],["FromUtf16Error","A possible error value when converting a `String` from a UTF-16 byte slice.This type is the error type for the `from_utf16()` method on `String`.ExamplesBasic usage:"],["FromUtf8Error","A possible error value when converting a `String` from a UTF-8 byte vector.This type is the error type for the `from_utf8()` method on `String`. It is designed in such a way to carefully avoid reallocations: the `into_bytes()` method will give back the byte vector that was used in the conversion attempt.The `Utf8Error` type provided by `std::str` represents an error that may occur when converting a slice of `u8`s to a `&str`. In this sense, it's an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error` through the `utf8_error()` method.ExamplesBasic usage:"],["String","A UTF-8 encoded, growable string.The `String` type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive `str`.ExamplesYou can create a `String` from a literal string with `String::from`:You can append a `char` to a `String` with the `push()` method, and append a `&str` with the `push_str()` method:If you have a vector of UTF-8 bytes, you can create a `String` from it with the `from_utf8()` method:UTF-8`String`s are always valid UTF-8. This has a few implications, the first of which is that if you need a non-UTF-8 string, consider `OsString`. It is similar, but without the UTF-8 constraint. The second implication is that you cannot index into a `String`:Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furtheremore, it's not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The `as_bytes()` and `chars()` methods return iterators over the first two, respectively.Deref`String`s implement `Deref``<Target=str>`, and so inherit all of `str`'s methods. In addition, this means that you can pass a `String` to any function which takes a `&str` by using an ampersand (`&`):This will create a `&str` from the `String` and pass it in. This conversion is very inexpensive, and so generally, functions will accept `&str`s as arguments unless they need a `String` for some specific reason.RepresentationA `String` is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer `String` uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.This buffer is always stored on the heap.You can look at these with the `as_ptr()`, `len()`, and `capacity()` methods:If a `String` has enough capacity, adding elements to it will not re-allocate. For example, consider this program:This will output the following:At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the `with_capacity()` method to allocate the correct capacity initially:We end up with a different output:Here, there's no need to allocate more memory inside the loop."]],"trait":[["ToString","A trait for converting a value to a `String`.This trait is automatically implemented for any type which implements the `Display` trait. As such, `ToString` shouldn't be implemented directly: `Display` should be implemented instead, and you get the `ToString` implementation for free."]]});