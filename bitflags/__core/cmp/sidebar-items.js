initSidebarItems({"enum":[["Ordering","An `Ordering` is the result of a comparison between two values.Examples"]],"fn":[["max","Compare and return the maximum of two values.Returns the second argument if the comparison determines them to be equal.Examples"],["min","Compare and return the minimum of two values.Returns the first argument if the comparison determines them to be equal.Examples"]],"trait":[["Eq","Trait for equality comparisons which are equivalence relations.This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must be (for all `a`, `b` and `c`):reflexive: `a == a`; symmetric: `a == b` implies `b == a`; and transitive: `a == b` and `b == c` implies `a == c`. This property cannot be checked by the compiler, and therefore `Eq` implies `PartialEq`, and has no extra methods.This trait can be used with `#[derive]`."],["Ord","Trait for types that form a total order.An order is a total order if it is (for all `a`, `b` and `c`):total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`. This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members."],["PartialEq","Trait for equality comparisons which are partial equivalence relations.This trait allows for partial equality, for types that do not have a full equivalence relation.  For example, in floating point numbers `NaN != NaN`, so floating point types implement `PartialEq` but not `Eq`.Formally, the equality must be (for all `a`, `b` and `c`):symmetric: `a == b` implies `b == a`; and transitive: `a == b` and `b == c` implies `a == c`. Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>` then `U: PartialEq<T>` and `T: PartialEq<V>`.PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.This trait can be used with `#[derive]`."],["PartialOrd","Trait for values that can be compared for a sort-order.The comparison must satisfy, for all `a`, `b` and `c`:antisymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`. Note that these requirements mean that the trait itself must be implemented symmetrically and transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T: PartialOrd<V>`.PartialOrd only requires implementation of the `partial_cmp` method, with the others generated from default implementations.However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section 5.11).This trait can be used with `#[derive]`. When `derive`d, it will produce an ordering based on the top-to-bottom declaration order of the struct's members."]]});