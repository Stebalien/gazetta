initSidebarItems({"fn":[["from_utf8","Converts a slice of bytes to a string slice.A string slice (`&str`) is made of bytes (`u8`), and a byte slice (`&[u8]`) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: `&str` requires that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid UTF-8, and then does the conversion.If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, `from_utf8_unchecked()`, which has the same behavior but skips the check.If you need a `String` instead of a `&str`, consider `String::from_utf8()`.Because you can stack-allocate a `[u8; N]`, and you can take a `&[u8]` of it, this function is one way to have a stack-allocated string. There is an example of this in the examples section below.ErrorsReturns `Err` if the slice is not UTF-8 with a description as to why the provided slice is not UTF-8.ExamplesBasic usage:Incorrect bytes:See the docs for `Utf8Error` for more details on the kinds of errors that can be returned.A \"stack allocated string\":"],["from_utf8_unchecked","Converts a slice of bytes to a string slice without checking that the string contains valid UTF-8.See the safe version, `from_utf8()`, for more information.SafetyThis function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that `&str`s are valid UTF-8.ExamplesBasic usage:"]],"mod":[["pattern","The string Pattern API.For more details, see the traits `Pattern`, `Searcher`, `ReverseSearcher` and `DoubleEndedSearcher`."]],"struct":[["Bytes","External iterator for a string's bytes. Use with the `std::iter` module.Created with the method `bytes()`."],["CharIndices","Iterator for a string's characters and their byte offsets."],["CharRange","Struct that contains a `char` and the index of the first byte of the next `char` in a string.  This can be used as a data structure for iterating over the UTF-8 bytes of a string."],["Chars","Iterator for the char (representing *Unicode Scalar Values*) of a stringCreated with the method `chars()`."],["Lines","Created with the method `lines()`."],["LinesAny","Created with the method `lines_any()`."],["MatchIndices","Created with the method `match_indices()`."],["Matches","Created with the method `matches()`."],["ParseBoolError","An error returned when parsing a `bool` from a string fails."],["RMatchIndices","Created with the method `rmatch_indices()`."],["RMatches","Created with the method `rmatches()`."],["RSplit","Created with the method `rsplit()`."],["RSplitN","Created with the method `rsplitn()`."],["RSplitTerminator","Created with the method `rsplit_terminator()`."],["Split","Created with the method `split()`."],["SplitN","Created with the method `splitn()`."],["SplitTerminator","Created with the method `split_terminator()`."],["SplitWhitespace","An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace."],["Utf16Units","External iterator for a string's UTF-16 code units.For use with the `std::iter` module."],["Utf8Error","Errors which can occur when attempting to interpret a sequence of `u8` as a string.As such, the `from_utf8` family of functions and methods for both `String`s and `&str`s make use of this error, for example."]],"trait":[["FromStr","A trait to abstract the idea of creating a new instance of a type from a string.`FromStr`'s `from_str()` method is often used implicitly, through `str`'s `parse()` method. See `parse()`'s documentation for examples."]]});