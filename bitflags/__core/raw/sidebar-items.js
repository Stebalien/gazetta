initSidebarItems({"struct":[["Slice","The representation of a slice like `&[T]`.This struct is guaranteed to have the layout of types like `&[T]`, `&str`, and `Box<[T]>`, but is not the type of such slices (e.g. the fields are not directly accessible on a `&[T]`) nor does it control that layout (changing the definition will not change the layout of a `&[T]`). It is only designed to be used by unsafe code that needs to manipulate the low-level details.However, it is not recommended to use this type for such code, since there are alternatives which may be safer:Creating a slice from a data pointer and length can be done with `std::slice::from_raw_parts` or `std::slice::from_raw_parts_mut` instead of `std::mem::transmute`ing a value of type `Slice`. Extracting the data pointer and length from a slice can be performed with the `as_ptr` (or `as_mut_ptr`) and `len` methods. If one does decide to convert a slice value to a `Slice`, the `Repr` trait in this module provides a method for a safe conversion from `&[T]` (and `&str`) to a `Slice`, more type-safe than a call to `transmute`.Examples"],["TraitObject","The representation of a trait object like `&SomeTrait`.This struct has the same layout as types like `&SomeTrait` and `Box<AnotherTrait>`. The Trait Objects chapter of the Book contains more details about the precise nature of these internals.`TraitObject` is guaranteed to match layouts, but it is not the type of trait objects (e.g. the fields are not directly accessible on a `&SomeTrait`) nor does it control that layout (changing the definition will not change the layout of a `&SomeTrait`). It is only designed to be used by unsafe code that needs to manipulate the low-level details.There is no `Repr` implementation for `TraitObject` because there is no way to refer to all trait objects generically, so the only way to create values of this type is with functions like `std::mem::transmute`. Similarly, the only way to create a true trait object from a `TraitObject` value is with `transmute`.Synthesizing a trait object with mismatched types—one where the vtable does not correspond to the type of the value to which the data pointer points—is highly likely to lead to undefined behavior.Examples"]],"trait":[["Repr","This trait is meant to map equivalences between raw structs and their corresponding rust values."]]});