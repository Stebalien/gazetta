initSidebarItems({"enum":[["LocalKeyState","Indicator of the state of a thread local storage key."]],"fn":[["catch_panic","Invokes a closure, capturing the cause of panic if one occurs.This function will return `Ok` with the closure's result if the closure does not panic, and will return `Err(cause)` if the closure panics. The `cause` returned is the object with which panic was originally invoked.It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.It is **not** recommended to use this function for a general try/catch mechanism. The `Result` type is more appropriate to use for functions that can fail on a regular basis.The closure provided is required to adhere to the `'static` bound to ensure that it cannot reference data in the parent stack frame, mitigating problems with exception safety. Furthermore, a `Send` bound is also required, providing the same safety guarantees as `thread::spawn` (ensuring the closure is properly isolated from the parent)."],["current","Gets a handle to the thread that invokes it."],["panicking","Determines whether the current thread is unwinding because of panic."],["park","Blocks unless or until the current thread's token is made available.Every thread is equipped with some basic low-level blocking support, via the `park()` function and the `unpark()` method. These can be used as a more CPU-efficient implementation of a spinlock.The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then parking (in a loop with a check for the token actually being acquired).A call to `park` does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.See the module documentation for more detail."],["park_timeout","Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).The semantics of this function are equivalent to `park()` except that the thread will be blocked for roughly no longer than *dur*. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely *dur* long.See the module doc for more detail.Platform behaviorPlatforms which do not support nanosecond precision for sleeping will have `dur` rounded up to the nearest granularity of time they can sleep for."],["park_timeout_ms","Blocks unless or until the current thread's token is made available or the specified duration has been reached (may wake spuriously).The semantics of this function are equivalent to `park()` except that the thread will be blocked for roughly no longer than *ms*. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely *ms* long.See the module doc for more detail."],["sleep","Puts the current thread to sleep for the specified amount of time.The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality.Platform behaviorOn Unix platforms this function will not return early due to a signal being received or a spurious wakeup. Platforms which do not support nanosecond precision for sleeping will have `dur` rounded up to the nearest granularity of time they can sleep for."],["sleep_ms","Puts the current thread to sleep for the specified amount of time.The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. Note that on unix platforms this function will not return early due to a signal being received or a spurious wakeup."],["spawn","Spawns a new thread, returning a `JoinHandle` for it.The join handle will implicitly *detach* the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes.) Additionally, the join handle provides a `join` method that can be used to join the child thread. If the child thread panics, `join` will return an `Err` containing the argument given to `panic`.PanicsPanics if the OS fails to create a thread; use `Builder::spawn` to recover from such errors."],["yield_now","Cooperatively gives up a timeslice to the OS scheduler."]],"struct":[["Builder","Thread configuration. Provides detailed control over the properties and behavior of new threads."],["JoinHandle","An owned permission to join on a thread (block on its termination).A `JoinHandle` *detaches* the child thread when it is dropped.Due to platform restrictions, it is not possible to `Clone` this handle: the ability to join a child thread is a uniquely-owned permission."],["Key",""],["Key",""],["KeyInner",""],["LocalKey","A thread local storage key which owns its contents.This key uses the fastest possible implementation available to it for the target platform. It is instantiated with the `thread_local!` macro and the primary method is the `with` method.The `with` method yields a reference to the contained value which cannot be sent across threads or escape the given closure.Initialization and DestructionInitialization is dynamically performed on the first call to `with()` within a thread, and values support destructors which will be run when a thread exits.ExamplesPlatform-specific behaviorNote that a \"best effort\" is made to ensure that destructors for types stored in thread local storage are run, but not all platforms can gurantee that destructors will be run for all types in thread local storage. For example, there are a number of known caveats where destructors are not run:On Unix systems when pthread-based TLS is being used, destructors will not be run for TLS values on the main thread when it exits. Note that the application will exit immediately after the main thread exits as well. On all platforms it's possible for TLS to re-initialize other TLS slots during destruction. Some platforms ensure that this cannot happen infinitely by preventing re-initialization of any slot that has been destroyed, but not all platforms have this guard. Those platforms that do not guard typically have a synthetic limit after which point no more destructors are run. On OSX, initializing TLS during destruction of other TLS slots can sometimes cancel *all* destructors for the current thread, whether or not the slots have already had their destructors run or not."],["ScopedKey","Type representing a thread local storage key corresponding to a reference to the type parameter `T`.Keys are statically allocated and can contain a reference to an instance of type `T` scoped to a particular lifetime. Keys provides two methods, `set` and `with`, both of which currently use closures to control the scope of their contents."],["Thread","A handle to a thread."]],"type":[["Result",""]]});