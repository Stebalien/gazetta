initSidebarItems({"mod":[["any","This module implements the `Any` trait, which enables dynamic typing of any `'static` type through runtime reflection.`Any` itself can be used to get a `TypeId`, and has more features when used as a trait object. As `&Any` (a borrowed trait object), it has the `is` and `downcast_ref` methods, to test if the contained value is of a given type, and to get a reference to the inner value as a type. As `&mut Any`, there is also the `downcast_mut` method, for getting a mutable reference to the inner value. `Box<Any>` adds the `downcast` method, which attempts to convert to a `Box<T>`. See the `Box` documentation for the full details.Note that &Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.ExamplesConsider a situation where we want to log out a value passed to a function. We know the value we're working on implements Debug, but we don't know its concrete type.  We want to give special treatment to certain types: in this case printing out the length of String values prior to their value. We don't know the concrete type of our value at compile time, so we need to use runtime reflection instead."],["ascii","Operations on ASCII strings and characters"],["borrow","A module for working with borrowed data."],["boxed","A pointer type for heap allocation.`Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of scope.ExamplesCreating a box:Creating a recursive data structure:This will print `Cons(1, Cons(2, Nil))`.Recursive structures must be boxed, because if the definition of `Cons` looked like this:It wouldn't work. This is because the size of a `List` depends on how many elements are in the list, and so we don't know how much memory to allocate for a `Cons`. By introducing a `Box`, which has a defined size, we know how big `Cons` needs to be."],["cell","Shareable mutable containers.Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e. the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`) references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast with typical Rust types that exhibit 'inherited mutability'.Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set` methods that change the interior value with a single method call. `Cell<T>` though is only compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>` type, acquiring a write lock before mutating.`RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are tracked 'at runtime', unlike Rust's native reference types which are entirely tracked statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt to borrow a value that is already mutably borrowed; when this happens it results in thread panic.When to choose interior mutabilityThe more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even *must* be used, e.g.Introducing mutability 'inside' of something immutable Implementation details of logically-immutable methods. Mutating implementations of `Clone`. Introducing mutability 'inside' of something immutableMany shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be cloned and shared between multiple parties. Because the contained values may be multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be impossible to mutate data inside of these smart pointers at all.It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce mutability:Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded scenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a multi-threaded situation.Implementation details of logically-immutable methodsOccasionally it may be desirable not to expose in an API that there is mutation happening \"under the hood\". This may be because logically the operation is immutable, but e.g. caching forces the implementation to perform mutation; or because you must employ mutation to implement a trait method that was originally defined to take `&self`.Mutating implementations of `Clone`This is simply a special - but common - case of the previous: hiding mutability for operations that appear to be immutable. The `clone` method is expected to not change the source value, and is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a `Cell<T>`."],["char","A character type.The `char` type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, `char` is a 'Unicode scalar value', which is similar to, but not the same as, a 'Unicode code point'.This module exists for technical reasons, the primary documentation for `char` is directly on the `char` primitive type itself.This module is the home of the iterator implementations for the iterators implemented on `char`, as well as some useful constants and conversion functions that convert various types to `char`."],["clone","The `Clone` trait for types that cannot be 'implicitly copied'In Rust, some simple types are \"implicitly copyable\" and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e. they do not contain owned boxes or implement `Drop`), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the `Clone` trait and calling the `clone` method."],["cmp","Functionality for ordering and comparison.This module defines both `PartialOrd` and `PartialEq` traits which are used by the compiler to implement comparison operators. Rust programs may implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators, and may implement `PartialEq` to overload the `==` and `!=` operators."],["collections","Collection types.Rust's standard collection library provides efficient implementations of the most common general purpose programming data structures. By using the standard implementations, it should be possible for two libraries to communicate without significant data conversion.To get this out of the way: you should probably just use `Vec` or `HashMap`. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline *niche* in comparison. Even when `Vec` and `HashMap` are technically suboptimal, they're probably a good enough choice to get started.Rust's collections can be grouped into four major categories:Sequences: `Vec`, `VecDeque`, `LinkedList` Maps: `HashMap`, `BTreeMap` Sets: `HashSet`, `BTreeSet` Misc: `BinaryHeap` When Should You Use Which Collection?These are fairly high-level and quick break-downs of when each collection should be considered. Detailed discussions of strengths and weaknesses of individual collections can be found on their own documentation pages.Use a `Vec` when:You want to collect items up to be processed or sent elsewhere later, and don't care about any properties of the actual values being stored. You want a sequence of elements in a particular order, and will only be appending to (or near) the end. You want a stack. You want a resizable array. You want a heap-allocated array. Use a `VecDeque` when:You want a `Vec` that supports efficient insertion at both ends of the sequence. You want a queue. You want a double-ended queue (deque). Use a `LinkedList` when:You want a `Vec` or `VecDeque` of unknown size, and can't tolerate amortization. You want to efficiently split and append lists. You are *absolutely* certain you *really*, *truly*, want a doubly linked list. Use a `HashMap` when:You want to associate arbitrary keys with an arbitrary value. You want a cache. You want a map, with no extra functionality. Use a `BTreeMap` when:You're interested in what the smallest or largest key-value pair is. You want to find the largest or smallest key that is smaller or larger than something. You want to be able to get all of the entries in order on-demand. You want a sorted map. Use the `Set` variant of any of these `Map`s when:You just want to remember which keys you've seen. There is no meaningful value to associate with your keys. You just want a set. Use a `BinaryHeap` when:You want to store a bunch of elements, but only ever want to process the \"biggest\" or \"most important\" one at any given time. You want a priority queue. PerformanceChoosing the right collection for the job requires an understanding of what each collection is good at. Here we briefly summarize the performance of different collections for certain important operations. For further details, see each type's documentation, and note that the names of actual methods may differ from the tables below on certain collections.Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an *amortized* cost are suffixed with a `*`.  Operations with an *expected* cost are suffixed with a `~`.All amortized costs are for the potential need to resize when capacity is exhausted.  If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.Only HashMap has expected costs, due to the probabilistic nature of hashing. It is theoretically possible, though very unlikely, for HashMap to experience worse performance.SequencesNote that where ties occur, Vec is generally going to be faster than VecDeque, and VecDeque is generally going to be faster than LinkedList.MapsFor Sets, all operations have the cost of the equivalent Map operation.Note that BTreeMap's precise performance depends on the value of B.Correct and Efficient Usage of CollectionsOf course, knowing which collection is the right one for the job doesn't instantly permit you to use it correctly. Here are some quick tips for efficient and correct usage of the standard collections in general. If you're interested in how to use a specific collection in particular, consult its documentation for detailed discussion and code examples.Capacity ManagementMany collections provide several constructors and methods that refer to \"capacity\".  These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the elements stored in the collection, but for the collection to do this would be very inefficient. If the backing array was exactly the right size at all times, then every time an element is inserted, the collection would have to grow the array to fit it. Due to the way memory is allocated and managed on most computers, this would almost surely require allocating an entirely new array and copying every single element from the old one into the new one. Hopefully you can see that this wouldn't be very efficient to do on every operation.Most collections therefore use an *amortized* allocation strategy. They generally let themselves have a fair amount of unoccupied space so that they only have to grow on occasion. When they do grow, they allocate a substantially larger array to move the elements into so that it will take a while for another grow to be required. While this strategy is great in general, it would be even better if the collection *never* had to resize its backing array. Unfortunately, the collection itself doesn't have enough information to do this itself. Therefore, it is up to us programmers to give it hints.Any `with_capacity` constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. `Vec` and `VecDeque` can be relied on to allocate exactly the requested amount, though. Use `with_capacity` when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.When anticipating a large influx of elements, the `reserve` family of methods can be used to hint to the collection how much room it should make for the coming items.  As with `with_capacity`, the precise behavior of these methods will be specific to the collection of interest.For optimal performance, collections will generally avoid shrinking themselves.  If you believe that a collection will not soon contain any more elements, or just really need the memory, the `shrink_to_fit` method prompts the collection to shrink the backing array to the minimum size capable of holding its elements.Finally, if ever you're interested in what the actual capacity of the collection is, most collections provide a `capacity` method to query this information on demand.  This can be useful for debugging purposes, or for use with the `reserve` methods.IteratorsIterators are a powerful and robust mechanism used throughout Rust's standard libraries. Iterators provide a sequence of values in a generic, safe, efficient and convenient way. The contents of an iterator are usually *lazily* evaluated, so that only the values that are actually needed are ever actually produced, and no allocation need be done to temporarily store them. Iterators are primarily consumed using a `for` loop, although many functions also take iterators where a collection or sequence of values is desired.All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are `iter`, `iter_mut`, and `into_iter`. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.`iter` provides an iterator of immutable references to all the contents of a collection in the most \"natural\" order. For sequence collections like `Vec`, this means the items will be yielded in increasing order of index starting at 0. For ordered collections like `BTreeMap`, this means that the items will be yielded in sorted order.  For unordered collections like `HashMap`, the items will be yielded in whatever order the internal representation made most convenient. This is great for reading through all the contents of the collection.`iter_mut` provides an iterator of *mutable* references in the same order as `iter`.  This is great for mutating all the contents of the collection.`into_iter` transforms the actual collection into an iterator over its contents by-value. This is great when the collection itself is no longer needed, and the values are needed elsewhere. Using `extend` with `into_iter` is the main way that contents of one collection are moved into another. `extend` automatically calls `into_iter`, and takes any `T: IntoIterator`. Calling `collect` on an iterator itself is also a great way to convert one collection into another. Both of these methods should internally use the capacity management tools discussed in the previous section to do this as efficiently as possible.Iterators also provide a series of *adapter* methods for performing common threads to sequences. Among the adapters are functional favorites like `map`, `fold`, `skip`, and `take`. Of particular interest to collections is the `rev` adapter, that reverses any iterator that supports this operation. Most collections provide reversible iterators as the way to iterate over them in reverse order.Several other collection methods also return iterators to yield a sequence of results but avoid allocating an entire collection to store the result in. This provides maximum flexibility as `collect` or `extend` can be called to \"pipe\" the sequence into any collection if desired. Otherwise, the sequence can be looped over with a `for` loop. The iterator can also be discarded after partial use, preventing the computation of the unused items.EntriesThe `entry` API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a `find` followed by an `insert`, effectively duplicating the search effort on each insertion.When a user calls `map.entry(&key)`, the map will search for the key and then yield a variant of the `Entry` enum.If a `Vacant(entry)` is yielded, then the key *was not* found. In this case the only valid operation is to `insert` a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.If an `Occupied(entry)` is yielded, then the key *was* found. In this case, the user has several options: they can `get`, `insert`, or `remove` the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant `insert` case.ExamplesHere are the two primary ways in which `entry` is used. First, a simple example where the logic performed on the values is trivial.Counting the number of times each character in a string occursWhen the logic to be performed on the value is more complex, we may simply use the `entry` API to ensure that the value is initialized, and perform the logic afterwards.Tracking the inebriation of customers at a barInsert and complex keysIf we have a more complex key, calls to `insert()` will not update the value of the key. For example:"],["convert","Traits for conversions between types.The traits in this module provide a general way to talk about conversions from one type to another. They follow the standard Rust conventions of `as`/`into`/`from`.Like many traits, these are often used as bounds for generic functions, to support arguments of multiple types.Impl the `As*` traits for reference-to-reference conversions Impl the `Into` trait when you want to consume the value in the conversion The `From` trait is the most flexible, useful for values _and_ references conversions As a library writer, you should prefer implementing `From<T>` rather than `Into<U>`, as `From` provides greater flexibility and offer the equivalent `Into` implementation for free, thanks to a blanket implementation in the standard library.**Note: these traits must not fail**. If the conversion can fail, you must use a dedicated method which return an `Option<T>` or a `Result<T, E>`.Generic impl`AsRef` and `AsMut` auto-dereference if the inner type is a reference `From<U> for T` implies `Into<T> for U` `From` and `Into` are reflexive, which means that all types can `into()` themselves and `from()` themselves See each trait for usage examples."],["default","The `Default` trait for types which may have meaningful default values.Sometimes, you want to fall back to some kind of default value, and don't particularly care what it is. This comes up often with `struct`s that define a set of options:How can we define some default values? You can use `Default`:Now, you get all of the default values. Rust implements `Default` for various primitives types. If you have your own type, you need to implement `Default` yourself:If you want to override a particular option, but still retain the other defaults:"],["dynamic_lib","Dynamic library facilities.A simple wrapper over the platform's dynamic library facilities"],["env","Inspection and manipulation of the process's environment.This module contains methods to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories."],["error","Traits for working with Errors.The `Error` trait`Error` is a trait representing the basic expectations for error values, i.e. values of type `E` in `Result<T, E>`. At a minimum, errors must provide a description, but they may optionally provide additional detail (via `Display`) and cause chain information:The `cause` method is generally used when errors cross \"abstraction boundaries\", i.e.  when a one module must report an error that is \"caused\" by an error from a lower-level module. This setup makes it possible for the high-level module to provide its own errors that do not commit to any particular implementation, but also reveal some of its implementation for debugging via `cause` chains."],["f32","The 32-bit floating point type.*See also the `f32` primitive type.*"],["f64","The 64-bit floating point type.*See also the `f64` primitive type.*"],["ffi","Utilities related to FFI bindings."],["fmt","Utilities for formatting and printing stringsThis module contains the runtime support for the `format!` syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings and streams.UsageThe `format!` macro is intended to be familiar to those coming from C's printf/fprintf functions or Python's `str.format` function. In its current revision, the `format!` macro returns a `String` type which is the result of the formatting. In the future it will also be able to pass in a stream to format arguments directly while performing minimal allocations.Some examples of the `format!` extension are:From these, you can see that the first argument is a format string. It is required by the compiler for this to be a string literal; it cannot be a variable passed in (in order to perform validity checking). The compiler will then parse the format string and determine if the list of arguments provided is suitable to pass to this format string.Positional parametersEach formatting argument is allowed to specify which value argument it's referencing, and if omitted it is assumed to be \"the next argument\". For example, the format string `{} {} {}` would take three parameters, and they would be formatted in the same order as they're given. The format string `{2} {1} {0}`, however, would format arguments in reverse order.Things can get a little tricky once you start intermingling the two types of positional specifiers. The \"next argument\" specifier can be thought of as an iterator over the argument. Each time a \"next argument\" specifier is seen, the iterator advances. This leads to behavior like this:The internal iterator over the argument has not been advanced by the time the first `{}` is seen, so it prints the first argument. Then upon reaching the second `{}`, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string, although it must always be referred to with the same type.Named parametersRust itself does not have a Python-like equivalent of named parameters to a function, but the `format!` macro is a syntax extension which allows it to leverage named parameters. Named parameters are listed at the end of the argument list and have the syntax:For example, the following `format!` expressions all use named argument:It is not valid to put positional parameters (those without names) after arguments which have names. Like with positional parameters, it is not valid to provide named parameters that are unused by the format string.Argument typesEach argument's type is dictated by the format string. It is a requirement that every argument is only ever referred to by one type. For example, this is an invalid format string:This is invalid because the first argument is both referred to as a hexadecimal as well as an octal.There are various parameters which do require a particular type, however. Namely, the `{:.*}` syntax, which sets the number of numbers after the decimal in floating-point types:If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type `usize`. Although a `usize` can be printed with `{}`, it is invalid to reference an argument as such. For example this is another invalid format string:Formatting traitsWhen requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via `{:x}` (like `i8` as well as `isize`).  The current mapping of types to traits is:*nothing* ⇒ `Display` `?` ⇒ `Debug` `o` ⇒ `Octal` `x` ⇒ `LowerHex` `X` ⇒ `UpperHex` `p` ⇒ `Pointer` `b` ⇒ `Binary` `e` ⇒ `LowerExp` `E` ⇒ `UpperExp` What this means is that any type of argument which implements the `fmt::Binary` trait can then be formatted with `{:b}`. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in `{}` or `{:6}`), then the format trait used is the `Display` trait.When implementing a format trait for your own type, you will have to implement a method of the signature:Your type will be passed as `self` by-reference, and then the function should emit output into the `f.buf` stream. It is up to each format trait implementation to correctly adhere to the requested formatting parameters. The values of these parameters will be listed in the fields of the `Formatter` struct. In order to help with this, the `Formatter` struct also provides some helper methods.Additionally, the return value of this function is `fmt::Result` which is a typedef to `Result<(), std::io::Error>` (also known as `std::io::Result<()>`). Formatting implementations should ensure that they return errors from `write!` correctly (propagating errors upward).An example of implementing the formatting traits would look like:`fmt::Display` vs `fmt::Debug`These two formatting traits have distinct purposes:`fmt::Display` implementations assert that the type can be faithfully represented as a UTF-8 string at all times. It is **not** expected that all types implement the `Display` trait. `fmt::Debug` implementations should be implemented for **all** public types. Output will typically represent the internal state as faithfully as possible. The purpose of the `Debug` trait is to facilitate debugging Rust code. In most cases, using `#[derive(Debug)]` is sufficient and recommended. Some examples of the output from both traits:Related macrosThere are a number of related macros in the `format!` family. The ones that are currently implemented are:`write!`This and `writeln` are two macros which are used to emit the format string to a specified stream. This is used to prevent intermediate allocations of format strings and instead directly write the output. Under the hood, this function is actually invoking the `write` function defined in this module. Example usage is:`print!`This and `println` emit their output to stdout. Similarly to the `write!` macro, the goal of these macros is to avoid intermediate allocations when printing output. Example usage is:`format_args!`This is a curious macro which is used to safely pass around an opaque object describing the format string. This object does not require any heap allocations to create, and it only references information on the stack. Under the hood, all of the related macros are implemented in terms of this. First off, some example usage is:The result of the `format_args!` macro is a value of type `fmt::Arguments`. This structure can then be passed to the `write` and `format` functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.For example, a logging library could use the standard formatting syntax, but it would internally pass around this structure until it has been determined where output should go to.SyntaxThe syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with python-like syntax, meaning that arguments are surrounded by `{}` instead of the C-like `%`. The actual grammar for the formatting syntax is:Formatting ParametersEach argument being formatted can be transformed by a number of formatting parameters (corresponding to `format_spec` in the syntax above). These parameters affect the string representation of what's being formatted. This syntax draws heavily from Python's, so it may seem a bit familiar.Fill/AlignmentThe fill character is provided normally in conjunction with the `width` parameter. This indicates that if the value being formatted is smaller than `width` some extra characters will be printed around it. The extra characters are specified by `fill`, and the alignment can be one of the following options:`<` - the argument is left-aligned in `width` columns `^` - the argument is center-aligned in `width` columns `>` - the argument is right-aligned in `width` columns Note that alignment may not be implemented by some types. A good way to ensure padding is applied is to format your input, then use this resulting string to pad your output.Sign/`#`/`0`These can all be interpreted as flags for a particular formatter.`+` - This is intended for numeric types and indicates that the sign     should always be printed. Positive signs are never printed by     default, and the negative sign is only printed by default for the     `Signed` trait. This flag indicates that the correct sign (`+` or `-`)     should always be printed. `-` - Currently not used `#` - This flag is indicates that the \"alternate\" form of printing should     be used. The alternate forms are: `#?` - pretty-print the `Debug` formatting `#x` - precedes the argument with a `0x` `#X` - precedes the argument with a `0x` `#b` - precedes the argument with a `0b` `#o` - precedes the argument with a `0o` `0` - This is used to indicate for integer formats that the padding should     both be done with a `0` character as well as be sign-aware. A format     like `{:08}` would yield `00000001` for the integer `1`, while the     same format would yield `-0000001` for the integer `-1`. Notice that     the negative version has one fewer zero than the positive version. WidthThis is a parameter for the \"minimum width\" that the format should take up. If the value's string does not fill up this many characters, then the padding specified by fill/alignment will be used to take up the required space.The default fill/alignment for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the `0` flag is specified for numerics, then the implicit fill character is `0`.The value for the width can also be provided as a `usize` in the list of parameters by using the `2$` syntax indicating that the second argument is a `usize` specifying the width.PrecisionFor non-numeric types, this can be considered a \"maximum width\". If the resulting string is longer than this width, then it is truncated down to this many characters and only those are emitted.For integral types, this is ignored.For floating-point types, this indicates how many digits after the decimal point should be printed.There are three possible ways to specify the desired `precision`:An integer `.N`:the integer `N` itself is the precision.An integer followed by dollar sign `.N$`:use format *argument* `N` (which must be a `usize`) as the precision.An asterisk `.*`:`.*` means that this `{...}` is associated with *two* format inputs rather than one: the first input holds the `usize` precision, and the second holds the value to print.  Note that in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers to the *value* to print, and the `precision` must come in the input preceding `<arg>`.For example, these:All print the same thing:While these:print two significantly different things:EscapingThe literal characters `{` and `}` may be included in a string by preceding them with the same character. For example, the `{` character is escaped with `{{` and the `}` character is escaped with `}}`."],["fs","Filesystem manipulation operationsThis module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of `std::os::$platform`."],["hash","Generic hashing support.This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use `#[derive(Hash)]`:ExamplesIf you need more control over how a value is hashed, you need to implement the trait `Hash`:"],["i16","The 16-bit signed integer type.*See also the `i16` primitive type.*"],["i32","The 32-bit signed integer type.*See also the `i32` primitive type.*"],["i64","The 64-bit signed integer type.*See also the `i64` primitive type.*"],["i8","The 8-bit signed integer type.*See also the `i8` primitive type.*"],["intrinsics","rustc compiler intrinsics.The corresponding definitions are in librustc_trans/trans/intrinsic.rs.VolatilesThe volatile intrinsics provide operations intended to act on I/O memory, which are guaranteed to not be reordered by the compiler across other volatile intrinsics. See the LLVM documentation on [volatile].AtomicsThe atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [atomics].A quick refresher on memory ordering:Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier. Release - a barrier for releasing a lock. Preceding reads and writes take place before the barrier. Sequentially consistent - sequentially consistent operations are guaranteed to happen in order. This is the standard mode for working with atomic types and is equivalent to Java's `volatile`."],["io","Traits, helpers, and type definitions for core I/O functionality.The `std::io` module contains a number of common things you'll need when doing input and output. The most core part of this module is the `Read` and `Write` traits, which provide the most general interface for reading and writing input and output.Read and WriteBecause they are traits, `Read` and `Write` are implemented by a number of other types, and you can implement them for your types too. As such, you'll see a few different types of I/O throughout the documentation in this module: `File`s, `TcpStream`s, and sometimes even `Vec<T>`s. For example, `Read` adds a `read()` method, which we can use on `File`s:`Read` and `Write` are so important, implementors of the two traits have a nickname: readers and writers. So you'll sometimes see 'a reader' instead of 'a type that implements the `Read` trait'. Much easier!Seek and BufReadBeyond that, there are two important traits that are provided: `Seek` and `BufRead`. Both of these build on top of a reader to control how the reading happens. `Seek` lets you control where the next byte is coming from:`BufRead` uses an internal buffer to provide a number of other ways to read, but to show it off, we'll need to talk about buffers in general. Keep reading!BufReader and BufWriterByte-based interfaces are unwieldy and can be inefficient, as we'd need to be making near-constant calls to the operating system. To help with this, `std::io` comes with two structs, `BufReader` and `BufWriter`, which wrap readers and writers. The wrapper uses a buffer, reducing the number of calls and providing nicer methods for accessing exactly what you want.For example, `BufReader` works with the `BufRead` trait to add extra methods to any reader:`BufWriter` doesn't add any new ways of writing; it just buffers every call to `write()`:Standard input and outputA very common source of input is standard input:And a very common source of output is standard output:Of course, using `io::stdout()` directly is less common than something like `println!`.Iterator typesA large number of the structures provided by `std::io` are for various ways of iterating over I/O. For example, `Lines` is used to split over lines:FunctionsThere are a number of functions that offer access to various features. For example, we can use three of these functions to copy everything from standard input to standard output:io::ResultLast, but certainly not least, is `io::Result`. This type is used as the return type of many `std::io` functions that can cause an error, and can be returned from your own functions as well. Many of the examples in this module use the `try!` macro:The return type of `read_input()`, `io::Result<()>`, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use `()`.Platform-specific behaviorMany I/O functions throughout the standard library are documented to indicate what various library or syscalls they are delegated to. This is done to help applications both understand what's happening under the hood as well as investigate any possibly unclear semantics. Note, however, that this is informative, not a binding contract. The implementation of many of these functions are subject to change over time and may call fewer or more syscalls/library functions."],["isize","The pointer-sized signed integer type.*See also the `isize` primitive type.*"],["iter","Composable external iterationIf you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.Before explaining more, let's talk about how this module is structured:OrganizationThis module is largely organized by type:Traits are the core portion: these traits define what kind of iterators exist and what you can do with them. The methods of these traits are worth putting some extra study time into. Functions provide some helpful ways to create some basic iterators. Structs are often the return types of the various methods on this module's traits. You'll usually want to look at the method that creates the `struct`, rather than the `struct` itself. For more detail about why, see 'Implementing Iterator'. That's it! Let's dig into iterators.IteratorThe heart and soul of this module is the `Iterator` trait. The core of `Iterator` looks like this:An iterator has a method, `next()`, which when called, returns an `Option``<Item>`. `next()` will return `Some(Item)` as long as there are elements, and once they've all been exhausted, will return `None` to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling `next()` again may or may not eventually start returning `Some(Item)` again at some point.`Iterator`'s full definition includes a number of other methods as well, but they are default methods, built on top of `next()`, and so you get them for free.Iterators are also composable, and it's common to chain them together to do more complex forms of processing. See the Adapters section below for more details.The three forms of iterationThere are three common methods which can create iterators from a collection:`iter()`, which iterates over `&T`. `iter_mut()`, which iterates over `&mut T`. `into_iter()`, which iterates over `T`. Various things in the standard library may implement one or more of the three, where appropriate.Implementing IteratorCreating an iterator of your own involves two steps: creating a `struct` to hold the iterator's state, and then `impl`ementing `Iterator` for that `struct`. This is why there are so many `struct`s in this module: there is one for each iterator and iterator adapter.Let's make an iterator named `Counter` which counts from `1` to `5`:This will print `1` through `5`, each on their own line.Calling `next()` this way gets repetitive. Rust has a construct which can call `next()` on your iterator, until it reaches `None`. Let's go over that next.for Loops and IntoIteratorRust's `for` loop syntax is actually sugar for iterators. Here's a basic example of `for`:This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?There's a trait in the standard library for converting something into an iterator: `IntoIterator`. This trait has one method, `into_iter()`, which converts the thing implementing `IntoIterator` into an iterator. Let's take a look at that `for` loop again, and what the compiler converts it into:Rust de-sugars this into:First, we call `into_iter()` on the value. Then, we match on the iterator that returns, calling `next()` over and over until we see a `None`. At that point, we `break` out of the loop, and we're done iterating.There's one more subtle bit here: the standard library contains an interesting implementation of `IntoIterator`:In other words, all `Iterator`s implement `IntoIterator`, by just returning themselves. This means two things:If you're writing an `Iterator`, you can use it with a `for` loop. If you're creating a collection, implementing `IntoIterator` for it will allow your collection to be used with the `for` loop. AdaptersFunctions which take an `Iterator` and return another `Iterator` are often called 'iterator adapters', as they're a form of the 'adapter pattern'.Common iterator adapters include `map()`, `take()`, and `collect()`. For more, see their documentation.LazinessIterators (and iterator adapters) are *lazy*. This means that just creating an iterator doesn't _do_ a whole lot. Nothing really happens until you call `next()`. This is sometimes a source of confusion when creating an iterator solely for its side effects. For example, the `map()` method calls a closure on each element it iterates over:This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:The idiomatic way to write a `map()` for its side effects is to use a `for` loop instead:The two most common ways to evaluate an iterator are to use a `for` loop like this, or using the `collect()` adapter to produce a new collection.InfinityIterators do not have to be finite. As an example, an open-ended range is an infinite iterator:It is common to use the `take()` iterator adapter to turn an infinite iterator into a finite one:This will print the numbers `0` through `4`, each on their own line."],["marker","Primitive traits and marker types representing basic 'kinds' of types.Rust types can be classified in various useful ways according to intrinsic properties of the type. These classifications, often called 'kinds', are represented as traits."],["mem","Basic functions for dealing with memoryThis module contains functions for querying the size and alignment of types, initializing and manipulating memory."],["net","Networking primitives for TCP/UDP communication."],["num","Additional functionality for numerics.This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information."],["ops","Overloadable operatorsImplementing these traits allows you to get an effect similar to overloading operators.Some of these traits are imported by the prelude, so they are available in every Rust program.Many of the operators take their operands by value. In non-generic contexts involving built-in types, this is usually not a problem. However, using these operators in generic code, requires some attention if values have to be reused as opposed to letting the operators consume them. One option is to occasionally use `clone()`. Another option is to rely on the types involved providing additional operator implementations for references. For example, for a user-defined type `T` which is supposed to support addition, it is probably a good idea to have both `T` and `&T` implement the traits `Add<T>` and `Add<&T>` so that generic code can be written without unnecessary cloning.ExamplesThis example creates a `Point` struct that implements `Add` and `Sub`, and then demonstrates adding and subtracting two `Point`s.See the documentation for each trait for a minimum implementation that prints something to the screen."],["option","Optional valuesType `Option` represents an optional value: every `Option` is either `Some` and contains a value, or `None`, and does not. `Option` types are very common in Rust code, as they have a number of uses:Initial values Return values for functions that are not defined over their entire input range (partial functions) Return value for otherwise reporting simple errors, where `None` is returned on error Optional struct fields Struct fields that can be loaned or \"taken\" Optional function arguments Nullable pointers Swapping things out of difficult situations Options are commonly paired with pattern matching to query the presence of a value and take action, always accounting for the `None` case.Options and pointers (\"nullable\" pointers)Rust's pointer types must always point to a valid location; there are no \"null\" pointers. Instead, Rust has *optional* pointers, like the optional owned box, `Option<Box<T>>`.The following example uses `Option` to create an optional box of `i32`. Notice that in order to use the inner `i32` value first the `check_optional` function needs to use pattern matching to determine whether the box has a value (i.e. it is `Some(...)`) or not (`None`).This usage of `Option` to create safe nullable pointers is so common that Rust does special optimizations to make the representation of `Option<Box<T>>` a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.ExamplesBasic pattern matching on `Option`:Initialize a result to `None` before a loop:"],["os","OS-specific functionality"],["panic","Panic support in the standard library"],["path","Cross-platform path manipulation.This module provides two types, `PathBuf` and `Path` (akin to `String` and `str`), for working with paths abstractly. These types are thin wrappers around `OsString` and `OsStr` respectively, meaning that they work directly on strings according to the local platform's path syntax.Simple usagePath manipulation includes both parsing components from slices and building new owned paths.To parse a path, you can create a `Path` slice from a `str` slice and start asking questions:To build or modify paths, use `PathBuf`:Path components and normalizationThe path APIs are built around the notion of \"components\", which roughly correspond to the substrings between path separators (`/` and, on Windows, ``). The APIs for path parsing are largely specified in terms of the path's components, so it's important to clearly understand how those are determined.A path can always be reconstructed into an *equivalent* path by putting together its components via `push`. Syntactically, the paths may differ by the normalization described below.Component typesComponents come in several types:Normal components are the default: standard references to files or directories. The path `a/b` has two normal components, `a` and `b`.Current directory components represent the `.` character. For example, `./a` has a current directory component and a normal component `a`.The root directory component represents a separator that designates starting from root. For example, `/a/b` has a root directory component followed by normal components `a` and `b`.On Windows, an additional component type comes into play:Prefix components, of which there is a large variety. For example, `C:` and `\\server\\share` are prefixes. The path `C:windows` has a prefix component `C:` and a normal component `windows`; the path `C:\\windows` has a prefix component `C:`, a root directory component, and a normal component `windows`. NormalizationAside from splitting on the separator(s), there is a small amount of \"normalization\":Repeated separators are ignored: `a/b` and `a//b` both have components `a` and `b`.Occurrences of `.` are normalized away, *except* if they are at the beginning of the path (in which case they are often meaningful in terms of path searching). So, for example, `a/./b`, `a/b/`, `/a/b/.` and `a/b` all have components `a` and `b`, but `./a/b` has a leading current directory component.No other normalization takes place by default. In particular, `a/c` and `a/b/../c` are distinct, to account for the possibility that `b` is a symbolic link (so its parent isn't `a`). Further normalization is possible to build on top of the components APIs, and will be included in this library in the near future."],["prelude","The Rust PreludeRust comes with a variety of things in its standard library. However, if you had to manually import every single thing that you used, it would be very verbose. But importing a lot of things that a program never uses isn't good either. A balance needs to be struck.The *prelude* is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.On a technical level, Rust insertsinto the crate root of every crate, andinto every module.Other preludesPreludes can be seen as a pattern to make using multiple types more convenient. As such, you'll find other preludes in the standard library, such as `std::io::prelude`. Various libraries in the Rust ecosystem may also define their own preludes.The difference between 'the prelude' and these other preludes is that they are not automatically `use`'d, and must be imported manually. This is still easier than importing all of their constituent components.Prelude contentsThe current version of the prelude (version 1) lives in `std::prelude::v1`, and reexports the following.`std::marker`::{`Copy`, `Send`, `Sized`, `Sync`}. The marker traits indicate fundamental properties of types. `std::ops`::{`Drop`, `Fn`, `FnMut`, `FnOnce`}. Various operations for both destructors and overloading `()`. `std::mem`::`drop`, a convenience function for explicitly dropping a value. `std::boxed`::`Box`, a way to allocate values on the heap. `std::borrow`::`ToOwned`, The conversion trait that defines `to_owned()`, the generic method for creating an owned type from a borrowed type. `std::clone`::`Clone`, the ubiquitous trait that defines `clone()`, the method for producing a copy of a value. `std::cmp`::{`PartialEq`, `PartialOrd`, `Eq`, `Ord` }. The comparison traits, which implement the comparison operators and are often seen in trait bounds. `std::convert`::{`AsRef`, `AsMut`, `Into`, `From`}. Generic conversions, used by savvy API authors to create overloaded methods. `std::default`::`Default`, types that have default values. `std::iter`::{`Iterator`, `Extend`, `IntoIterator`, `DoubleEndedIterator`, `ExactSizeIterator`}. Iterators of various kinds. `std::option`::`Option`::{`self`, `Some`, `None`}. A type which expresses the presence or absence of a value. This type is so commonly used, its variants are also exported. `std::result`::`Result`::{`self`, `Ok`, `Err`}. A type for functions that may succeed or fail. Like `Option`, its variants are exported as well. `std::slice`::`SliceConcatExt`, a trait that exists for technical reasons, but shouldn't have to exist. It provides a few useful methods on slices. `std::string`::{`String`, `ToString`}, heap allocated strings. `std::vec`::`Vec`, a growable, heap-allocated vector."],["process","Working with processes."],["ptr","Raw, unsafe pointers, `*const T`, and `*mut T`*See also the pointer primitive types.*"],["raw","Contains struct definitions for the layout of compiler built-in types.They can be used as targets of transmutes in unsafe code for manipulating the raw representations directly.Their definition should always match the ABI defined in `rustc::back::abi`."],["rc","Thread-local reference-counted boxes (the `Rc<T>` type).The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic, and will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the overhead of atomic reference counting.The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value has already been dropped.For example, a tree with parent pointers can be represented by putting the nodes behind strong `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.ExamplesConsider a scenario where a set of `Gadget`s are owned by a given `Owner`. We want to have our `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.If our requirements change, and we also need to be able to traverse from Owner → Gadget, we will run into problems: an `Rc<T>` pointer from Owner → Gadget introduces a cycle between the objects. This means that their reference counts can never reach 0, and the objects will remain allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These pointers don't contribute to the total count.Rust actually makes it somewhat difficult to produce this loop in the first place: in order to end up with two objects that point at each other, one of them needs to be mutable. This is problematic because `Rc<T>` enforces memory safety by only giving out shared references to the object it wraps, and these don't allow direct mutation. We need to wrap the part of the object we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell` documentation for more details on interior mutability."],["result","Error handling with the `Result` type`Result<T, E>` is the type used for returning and propagating errors. It is an enum with the variants, `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error and containing an error value.Functions return `Result` whenever errors are expected and recoverable. In the `std` crate `Result` is most prominently used for I/O.A simple function returning `Result` might be defined and used like so:Pattern matching on `Result`s is clear and straightforward for simple cases, but `Result` comes with some convenience methods that make working with it more succinct.Results must be usedA common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. Result is annotated with the #[must_use] attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes `Result` especially useful with functions that may encounter errors but don't otherwise return a useful value.Consider the `write_all` method defined for I/O types by the `Write` trait:*Note: The actual definition of `Write` uses `io::Result`, which is just a synonym for `Result<T, io::Error>`.*This method doesn't produce a value, but the write may fail. It's crucial to handle the error case, and *not* write something like this:If you *do* write that in Rust, the compiler will give you a warning (by default, controlled by the `unused_must_use` lint).You might instead, if you don't want to handle the error, simply assert success with `expect`. This will panic if the write fails, providing a marginally useful message indicating why:You might also simply assert success:Or propagate the error up the call stack with `try!`:The `try!` macroWhen writing code that calls many functions that return the `Result` type, the error handling can be tedious.  The `try!` macro hides some of the boilerplate of propagating errors up the call stack.It replaces this:With this:*It's much nicer!*Wrapping an expression in `try!` will result in the unwrapped success (`Ok`) value, unless the result is `Err`, in which case `Err` is returned early from the enclosing function. Its simple definition makes it clear:`try!` is imported by the prelude and is available everywhere, but it can only be used in functions that return `Result` because of the early return of `Err` that it provides."],["slice","A dynamically-sized view into a contiguous sequence, `[T]`.Slices are a view into a block of memory represented as a pointer and a length.Slices are either mutable or shared. The shared slice type is `&[T]`, while the mutable slice type is `&mut [T]`, where `T` represents the element type. For example, you can mutate the block of memory that a mutable slice points to:Here are some of the things this module contains:StructsThere are several structs that are useful for slices, such as `Iter`, which represents iteration over a slice.Trait ImplementationsThere are several implementations of common traits for slices. Some examples include:`Clone` `Eq`, `Ord` - for slices whose element type are `Eq` or `Ord`. `Hash` - for slices whose element type is `Hash` IterationThe slices implement `IntoIterator`. The iterator yields references to the slice elements.The mutable slice yields mutable references to the elements:This iterator yields mutable references to the slice's elements, so while the element type of the slice is `i32`, the element type of the iterator is `&mut i32`.`.iter()` and `.iter_mut()` are the explicit methods to return the default iterators. Further methods that return iterators are `.split()`, `.splitn()`, `.chunks()`, `.windows()` and more. *See also the slice primitive type.*"],["str","Unicode string slices*See also the `str` primitive type.*"],["string","A UTF-8 encoded, growable string.This module contains the `String` type, a trait for converting `ToString`s, and several error types that may result from working with `String`s.ExamplesThere are multiple ways to create a new `String` from a string literal:You can create a new `String` from an existing one by concatenating with `+`:If you have a vector of valid UTF-8 bytes, you can make a `String` out of it. You can do the reverse too."],["sync","Useful synchronization primitivesThis module contains useful safe and unsafe synchronization primitives. Most of the primitives in this module do not provide any sort of locking and/or blocking at all, but rather provide the necessary tools to build other types of concurrent primitives."],["thread","Native threadsThe threading modelAn executing Rust program consists of a collection of native OS threads, each with their own stack and local state.Communication between threads can be done through channels, Rust's message-passing types, along with other forms of thread synchronization and shared-memory data structures. In particular, types that are guaranteed to be threadsafe are easily shared between threads using the atomically-reference-counted container, `Arc`.Fatal logic errors in Rust cause *thread panic*, during which a thread will unwind the stack, running destructors and freeing owned resources. Thread panic is unrecoverable from within the panicking thread (i.e. there is no 'try/catch' in Rust), but the panic may optionally be detected from a different thread. If the main thread panics, the application will exit with a non-zero exit code.When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).The `Thread` typeThreads are represented via the `Thread` type, which you can get in one of two ways:By spawning a new thread, e.g. using the `thread::spawn` function. By requesting the current thread, using the `thread::current` function. Threads can be named, and provide some built-in support for low-level synchronization (described below).The `thread::current()` function is available even for threads not spawned by the APIs of this module.Spawning a threadA new thread can be spawned using the `thread::spawn` function:In this example, the spawned thread is \"detached\" from the current thread. This means that it can outlive its parent (the thread that spawned it), unless this parent is the main thread.The parent thread can also wait on the completion of the child thread; a call to `spawn` produces a `JoinHandle`, which provides a `join` method for waiting:The `join` method returns a `Result` containing `Ok` of the final value produced by the child thread, or `Err` of the value given to a call to `panic!` if the child panicked.Configuring threadsA new thread can be configured before it is spawned via the `Builder` type, which currently allows you to set the name and stack size for the child thread:Blocking support: park and unparkEvery thread is equipped with some basic low-level blocking support, via the `park` and `unpark` functions.Conceptually, each `Thread` handle has an associated token, which is initially not present:The `thread::park()` function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return *spuriously*, without consuming the token. `thread::park_timeout()` does the same, but allows specifying a maximum time to block the thread for.The `unpark()` method on a `Thread` atomically makes the token available if it wasn't already.In other words, each `Thread` acts a bit like a semaphore with initial count 0, except that the semaphore is *saturating* (the count cannot go above 1), and can return spuriously.The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then `park`ing. When some desired condition is met, another thread calls `unpark` on the handle.The motivation for this design is twofold:It avoids the need to allocate mutexes and condvars when building new synchronization primitives; the threads already provide basic blocking/signaling.It can be implemented very efficiently on many platforms.Thread-local storageThis module also provides an implementation of thread local storage for Rust programs. Thread local storage is a method of storing data into a global variable which each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.At a high level, this module provides two variants of storage:Owned thread-local storage. This is a type of thread local key which owns the value that it contains, and will destroy the value when the thread exits. This variant is created with the `thread_local!` macro and can contain any value which is `'static` (no borrowed pointers).Scoped thread-local storage. This type of key is used to store a reference to a value into local storage temporarily for the scope of a function call. There are no restrictions on what types of values can be placed into this key.Both forms of thread local storage provide an accessor function, `with`, which will yield a shared reference to the value to the specified closure. Thread-local keys only allow shared access to values as there is no way to guarantee uniqueness if a mutable borrow was allowed. Most values will want to make use of some form of **interior mutability** through the `Cell` or `RefCell` types."],["time","Temporal quantification."],["u16","The 16-bit unsigned integer type.*See also the `u16` primitive type.*"],["u32","The 32-bit unsigned integer type.*See also the `u32` primitive type.*"],["u64","The 64-bit unsigned integer type.*See also the `u64` primitive type.*"],["u8","The 8-bit unsigned integer type.*See also the `u8` primitive type.*"],["usize","The pointer-sized unsigned integer type.*See also the `usize` primitive type.*"],["vec","A contiguous growable array type with heap-allocated contents, written `Vec<T>` but pronounced 'vector.'Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and `O(1)` pop (from the end).ExamplesYou can explicitly create a `Vec<T>` with `new()`:...or by using the `vec!` macro:You can `push` values onto the end of a vector (which will grow the vector as needed):Popping values works in much the same way:Vectors also support indexing (through the `Index` and `IndexMut` traits):"]]});