initSidebarItems({"struct":[["PhantomData","`PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`, even though it does not. This allows you to inform the compiler about certain safety properties of your code.For a more in-depth explanation of how to use `PhantomData<T>`, please see the Nomicon.A ghastly note ðŸ‘»ðŸ‘»ðŸ‘»Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not identical. Phantom types are a more general concept that don't require `PhantomData<T>` to implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.ExamplesUnused lifetime parameterPerhaps the most common time that `PhantomData` is required is with a struct that has an unused lifetime parameter, typically as part of some unsafe code. For example, here is a struct `Slice` that has two pointers of type `*const T`, presumably pointing into an array somewhere:The intention is that the underlying data is only valid for the lifetime `'a`, so `Slice` should not outlive `'a`. However, this intent is not expressed in the code, since there are no uses of the lifetime `'a` and hence it is not clear what data it applies to. We can correct this by telling the compiler to act *as if* the `Slice` struct contained a borrowed reference `&'a T`:This also in turn requires that we annotate `T:'a`, indicating that `T` is a type that can be borrowed for the lifetime `'a`.Unused type parametersIt sometimes happens that there are unused type parameters that indicate what type of data a struct is \"tied\" to, even though that data is not actually found in the struct itself. Here is an example where this arises when handling external resources over a foreign function interface. `PhantomData<T>` can prevent mismatches by enforcing types in the method implementations:Indicating ownershipAdding a field of type `PhantomData<T>` also indicates that your struct owns data of type `T`. This in turn implies that when your struct is dropped, it may in turn drop one or more instances of the type `T`, though that may not be apparent from the other structure of the type itself. This is commonly necessary if the structure is using a raw pointer like `*mut T` whose referent may be dropped when the type is dropped, as a `*mut T` is otherwise not treated as owned.If your struct does not in fact *own* the data of type `T`, it is better to use a reference type, like `PhantomData<&'a T>` (ideally) or `PhantomData<*const T>` (if no lifetime applies), so as not to indicate ownership."]],"trait":[["Copy","Types that can be copied by simply copying bits (i.e. `memcpy`).By default, variable bindings have 'move semantics.' In other words:However, if a type implements `Copy`, it instead has 'copy semantics':It's important to note that in these two examples, the only difference is if you are allowed to access `x` after the assignment: a move is also a bitwise copy under the hood.When can my type be `Copy`?A type can implement `Copy` if all of its components implement `Copy`. For example, this `struct` can be `Copy`:A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we attempt to derive a `Copy` implementation, we'll get an error:How can I implement `Copy`?There are two ways to implement `Copy` on your type:andThere is a small difference between the two: the `derive` strategy will also place a `Copy` bound on type parameters, which isn't always desired.When can my type _not_ be `Copy`?Some types can't be copied safely. For example, copying `&mut T` would create an aliased mutable reference, and copying `String` would result in two attempts to free the same buffer.Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's managing some resource besides its own `size_of::<T>()` bytes.When should my type be `Copy`?Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing to consider though: if you think your type may _not_ be able to implement `Copy` in the future, then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking change: that second example would fail to compile if we made `Foo` non-`Copy`.DerivableThis trait can be used with `#[derive]`."],["Reflect","Types that can be reflected over.This trait is implemented for all types. Its purpose is to ensure that when you write a generic function that will employ reflection, that must be reflected (no pun intended) in the generic bounds of that function. Here is an example:Without the declaration `T: Reflect`, `foo` would not type check (note: as a matter of style, it would be preferable to write `T: Any`, because `T: Any` implies `T: Reflect` and `T: 'static`, but we use `Reflect` here to show how it works). The `Reflect` bound thus serves to alert `foo`'s caller to the fact that `foo` may behave differently depending on whether `T = u32` or not. In particular, thanks to the `Reflect` bound, callers know that a function declared like `fn bar<T>(...)` will always act in precisely the same way no matter what type `T` is supplied, because there are no bounds declared on `T`. (The ability for a caller to reason about what a function may do based solely on what generic bounds are declared is often called the \"parametricity property\".)"],["Send","Types that can be transferred across thread boundaries.This trait is automatically derived when the compiler determines it's appropriate."],["Sized","Types with a constant size known at compile-time.All type parameters which can be bounded have an implicit bound of `Sized`. The special syntax `?Sized` can be used to remove this bound if it is not appropriate."],["Sync","Types that can be safely shared between threads when aliased.The precise definition is: a type `T` is `Sync` if `&T` is thread-safe. In other words, there is no possibility of data races when passing `&T` references between threads.As one would expect, primitive types like `u8` and `f64` are all `Sync`, and so are simple aggregate types containing them (like tuples, structs and enums). More instances of basic `Sync` types include \"immutable\" types like `&T` and those with simple inherited mutability, such as `Box<T>`, `Vec<T>` and most other collection types. (Generic parameters need to be `Sync` for their container to be `Sync`.)A somewhat surprising consequence of the definition is `&mut T` is `Sync` (if `T` is `Sync`) even though it seems that it might provide unsynchronized mutation. The trick is a mutable reference stored in an aliasable reference (that is, `& &mut T`) becomes read-only, as if it were a `& &T`, hence there is no risk of a data race.Types that are not `Sync` are those that have \"interior mutability\" in a non-thread-safe way, such as `Cell` and `RefCell` in `std::cell`. These types allow for mutation of their contents even when in an immutable, aliasable slot, e.g. the contents of `&Cell<T>` can be `.set`, and do not ensure data races are impossible, hence they cannot be `Sync`. A higher level example of a non-`Sync` type is the reference counted pointer `std::rc::Rc`, because any reference `&Rc<T>` can clone a new reference, which modifies the reference counts in a non-atomic way.For cases when one does need thread-safe interior mutability, types like the atomics in `std::sync` and `Mutex` & `RWLock` in the `sync` crate do ensure that any mutation cannot cause data races.  Hence these types are `Sync`.Any types with interior mutability must also use the `std::cell::UnsafeCell` wrapper around the value(s) which can be mutated when behind a `&` reference; not doing this is undefined behavior (for example, `transmute`-ing from `&T` to `&mut T` is invalid).This trait is automatically derived when the compiler determines it's appropriate."],["Unsize","Types that can be \"unsized\" to a dynamically sized type."]]});