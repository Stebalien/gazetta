initSidebarItems({"constant":[["ATOMIC_BOOL_INIT","An `AtomicBool` initialized to `false`."],["ATOMIC_ISIZE_INIT","An `AtomicIsize` initialized to `0`."],["ATOMIC_USIZE_INIT","An `AtomicUsize` initialized to `0`."]],"enum":[["Ordering","Atomic memory orderingsMemory orderings limit the ways that both the compiler and CPU may reorder instructions around atomic operations. At its most restrictive, \"sequentially consistent\" atomics allow neither reads nor writes to be moved either before or after the atomic operation; on the other end \"relaxed\" atomics allow all reorderings.Rust's memory orderings are the same as LLVM's."]],"fn":[["fence","An atomic fence.A fence 'A' which has `Release` ordering semantics, synchronizes with a fence 'B' with (at least) `Acquire` semantics, if and only if there exists atomic operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.Atomic operations with `Release` or `Acquire` semantics can also synchronize with a fence.A fence which has `SeqCst` ordering, in addition to having both `Acquire` and `Release` semantics, participates in the global program order of the other `SeqCst` operations and/or fences.Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.PanicsPanics if `order` is `Relaxed`."]],"struct":[["AtomicBool","A boolean type which can be safely shared between threads."],["AtomicIsize","A signed integer type which can be safely shared between threads."],["AtomicPtr","A raw pointer type which can be safely shared between threads."],["AtomicUsize","An unsigned integer type which can be safely shared between threads."]]});