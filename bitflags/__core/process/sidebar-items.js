initSidebarItems({"fn":[["exit","Terminates the current process with the specified exit code.This function will never return and will immediately terminate the current process. The exit code is passed through to the underlying OS and will be available for consumption by another process.Note that because this function never returns, and that it terminates the process, no destructors on the current stack or any other thread's stack will be run. If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run."]],"struct":[["Child","Representation of a running or exited child process.This structure is used to represent and manage child processes. A child process is created via the `Command` struct, which configures the spawning process and can itself be constructed using a builder-style interface.ExamplesNoteTake note that there is no implementation of `Drop` for child processes, so if you do not ensure the `Child` has exited then it will continue to run, even after the `Child` handle to the child process has gone out of scope.Calling `wait` (or other functions that wrap around it) will make the parent process wait until the child has actually exited before continuing."],["ChildStderr","A handle to a child process's stderr"],["ChildStdin","A handle to a child process's stdin"],["ChildStdout","A handle to a child process's stdout"],["Command","The `Command` type acts as a process builder, providing fine-grained control over how a new process should be spawned. A default configuration can be generated using `Command::new(program)`, where `program` gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:"],["ExitStatus","Describes the result of a process after it has terminated."],["Output","The output of a finished process."],["Stdio","Describes what to do with a standard I/O stream for a child process."]]});