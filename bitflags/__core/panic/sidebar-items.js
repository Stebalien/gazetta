initSidebarItems({"fn":[["propagate","Triggers a panic without invoking the panic handler.This is designed to be used in conjunction with `recover` to, for example, carry a panic across a layer of C code.Examples"],["recover","Invokes a closure, capturing the cause of panic if one occurs.This function will return `Ok` with the closure's result if the closure does not panic, and will return `Err(cause)` if the closure panics. The `cause` returned is the object with which panic was originally invoked.It is currently undefined behavior to unwind from Rust code into foreign code, so this function is particularly useful when Rust is called from another language (normally C). This can run arbitrary Rust code, capturing a panic and allowing a graceful handling of the error.It is **not** recommended to use this function for a general try/catch mechanism. The `Result` type is more appropriate to use for functions that can fail on a regular basis.The closure provided is required to adhere to the `RecoverSafe` to ensure that all captured variables are safe to cross this recover boundary. The purpose of this bound is to encode the concept of exception safety in the type system. Most usage of this function should not need to worry about this bound as programs are naturally panic safe without `unsafe` code. If it becomes a problem the associated `AssertRecoverSafe` wrapper type in this module can be used to quickly assert that the usage here is indeed exception safe.Examples"],["set_handler","Registers a custom panic handler, replacing any that was previously registered.The panic handler is invoked when a thread panics, but before it begins unwinding the stack. The default handler prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the `set_handler` and `take_handler` functions.The handler is provided with a `PanicInfo` struct which contains information about the origin of the panic, including the payload passed to `panic!` and the source code location from which the panic originated.The panic handler is a global resource.PanicsPanics if called from a panicking thread."],["take_handler","Unregisters the current panic handler, returning it.If no custom handler is registered, the default handler will be returned.PanicsPanics if called from a panicking thread."]],"struct":[["AssertRecoverSafe","A simple wrapper around a type to assert that it is panic safe.When using `recover` it may be the case that some of the closed over variables are not panic safe. For example if `&mut T` is captured the compiler will generate a warning indicating that it is not panic safe. It may not be the case, however, that this is actually a problem due to the specific usage of `recover` if panic safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed panic safe.Examples"],["Location","A struct containing information about the location of a panic."],["PanicInfo","A struct providing information about a panic."]],"trait":[["RecoverSafe","A marker trait which represents \"panic safe\" types in Rust.This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the `Send` and `Sync` traits. The purpose of this trait is to encode what types are safe to cross a `recover` boundary with no fear of panic safety.What is panic safety?In Rust a function can \"return\" early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two cricial components:A data structure is in a temporarily invalid state when the thread panics. This broken invariant is then later observed. Typically in Rust, it is difficult to perform step (2) because catching a panic involves either spawning a thread (which in turns makes it difficult to later witness broken invariants) or using the `recover` function in this module. Additionally, even if an invariant is witnessed, it typically isn't a problem in Rust because there's no uninitialized values (like in C or C++).It is possible, however, for **logical** invariants to be broken in Rust, which can end up causing behavioral bugs. Another key aspect of panic safety in Rust is that, in the absence of `unsafe` code, a panic cannot lead to memory unsafety.That was a bit of a whirlwind tour of panic safety, but for more information about panic safety and how it applies to Rust, see an associated RFC.What is `RecoverSafe`?Now that we've got an idea of what panic safety is in Rust, it's also important to understand what this trait represents. As mentioned above, one way to witness broken invariants is through the `recover` function in this module as it allows catching a panic and then re-using the environment of the closure.Simply put, a type `T` implements `RecoverSafe` if it cannot easily allow witnessing a broken invariant through the use of `recover` (catching a panic). This trait is a marker trait, so it is automatically implemented for many types, and it is also structurally composed (e.g. a struct is recover safe if all of its components are recover safe).Note, however, that this is not an unsafe trait, so there is not a succinct contract that this trait is providing. Instead it is intended as more of a \"speed bump\" to alert users of `recover` that broken invariants may be witnessed and may need to be accounted for.Who implements `RecoverSafe`?Types such as `&mut T` and `&RefCell<T>` are examples which are **not** recover safe. The general idea is that any mutable state which can be shared across `recover` is not recover safe by default. This is because it is very easy to witness a broken invariant outside of `recover` as the data is simply accessed as usual.Types like `&Mutex<T>`, however, are recover safe because they implement poisoning by default. They still allow witnessing a broken invariant, but they already provide their own \"speed bumps\" to do so.When should `RecoverSafe` be used?Is not intended that most types or functions need to worry about this trait. It is only used as a bound on the `recover` function and as mentioned above, the lack of `unsafe` means it is mostly an advisory. The `AssertRecoverSafe` wrapper struct in this module can be used to force this trait to be implemented for any closed over variables passed to the `recover` function (more on this below)."],["RefRecoverSafe","A marker trait representing types where a shared reference is considered recover safe.This trait is namely not implemented by `UnsafeCell`, the root of all interior mutability.This is a \"helper marker trait\" used to provide impl blocks for the `RecoverSafe` trait, for more information see that documentation."]]});