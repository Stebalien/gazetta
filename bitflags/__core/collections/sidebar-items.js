initSidebarItems({"enum":[["Bound","An endpoint of a range of keys."]],"mod":[["binary_heap","A priority queue implemented with a binary heap.Insertion and popping the largest element have `O(log n)` time complexity. Checking the largest element is `O(1)`. Converting a vector to a binary heap can be done in-place, and has `O(n)` complexity. A binary heap can also be converted to a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place heapsort.ExamplesThis is a larger example that implements Dijkstra's algorithm to solve the shortest path problem on a directed graph. It shows how to use `BinaryHeap` with custom types."],["btree_map",""],["btree_set",""],["hash_map","A hashmap"],["hash_set","A hashset"],["hash_state","Experimental support for providing custom hash algorithms to a HashMap and HashSet."],["linked_list","A doubly-linked list with owned nodes.The `LinkedList` allows pushing and popping elements at either end and is thus efficiently usable as a double-ended queue."],["vec_deque","VecDeque is a double-ended queue, which is implemented with the help of a growing ring buffer.This queue has `O(1)` amortized inserts and removals from both ends of the container. It also has `O(1)` indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable."]],"struct":[["BTreeMap","A map based on a B-Tree.B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this is done is *very* inefficient for modern computer architectures. In particular, every element is stored in its own individually heap-allocated node. This means that every single insertion triggers a heap-allocation, and every single comparison should be a cache-miss. Since these are both notably expensive things to do in practice, we are forced to at very least reconsider the BST strategy.A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do *more* comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i<sup>th</sup> element for some choice of i.Currently, our implementation simply performs naive linear search. This provides excellent performance on *small* nodes of elements which are cheap to compare. However in the future we would like to further explore choosing the optimal search strategy based on the choice of B, and possibly other factors. Using linear search, searching for a random element is expected to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice, however, performance is excellent.It is a logic error for a key to be modified in such a way that the key's ordering relative to any other key, as determined by the `Ord` trait, changes while it is in the map. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code."],["BTreeSet","A set based on a B-Tree.See `BTreeMap`'s documentation for a detailed discussion of this collection's performance benefits and drawbacks.It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the `Ord` trait, changes while it is in the set. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code."],["BinaryHeap","A priority queue implemented with a binary heap.This will be a max-heap.It is a logic error for an item to be modified in such a way that the item's ordering relative to any other item, as determined by the `Ord` trait, changes while it is in the heap. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code."],["HashMap","A hash map implementation which uses linear probing with Robin Hood bucket stealing.The hashes are all keyed by the thread-local random number generator on creation by default. This means that the ordering of the keys is randomized, but makes the tables more resistant to denial-of-service attacks (Hash DoS). This behavior can be overridden with one of the constructors.It is required that the keys implement the `Eq` and `Hash` traits, although this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself, it is important that the following property holds:In other words, if two keys are equal, their hashes must be equal.It is a logic error for a key to be modified in such a way that the key's hash, as determined by the `Hash` trait, or its equality, as determined by the `Eq` trait, changes while it is in the map. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.Relevant papers/articles:Pedro Celis. \"Robin Hood Hashing\" Emmanuel Goossaert. \"Robin Hood hashing\" Emmanuel Goossaert. \"Robin Hood hashing: backward shift deletion\" Examples`HashMap` also implements an `Entry API`, which allows for more complex methods of getting, setting, updating and removing keys and their values:The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`. We must also derive `PartialEq`."],["HashSet","An implementation of a hash set using the underlying representation of a HashMap where the value is ().As with the `HashMap` type, a `HashSet` requires that the elements implement the `Eq` and `Hash` traits. This can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself, it is important that the following property holds:In other words, if two keys are equal, their hashes must be equal.It is a logic error for an item to be modified in such a way that the item's hash, as determined by the `Hash` trait, or its equality, as determined by the `Eq` trait, changes while it is in the set. This is normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.ExamplesThe easiest way to use `HashSet` with a custom type is to derive `Eq` and `Hash`. We must also derive `PartialEq`, this will in the future be implied by `Eq`."],["LinkedList","A doubly-linked list."],["VecDeque","`VecDeque` is a growable ring buffer, which can be used as a double-ended queue efficiently.The \"default\" usage of this type as a queue is to use `push_back` to add to the queue, and `pop_front` to remove from the queue. `extend` and `append` push onto the back in this manner, and iterating over `VecDeque` goes front to back."]]});