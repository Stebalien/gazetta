initSidebarItems({"trait":[["AsMut","A cheap, mutable reference-to-mutable reference conversion.**Note: this trait must not fail**. If the conversion can fail, use a dedicated method which return an `Option<T>` or a `Result<T, E>`.Generic Impls`AsMut` auto-dereference if the inner type is a reference or a mutable reference (eg: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)"],["AsRef","A cheap, reference-to-reference conversion.`AsRef` is very similar to, but different than, `Borrow`. See the book for more.**Note: this trait must not fail**. If the conversion can fail, use a dedicated method which return an `Option<T>` or a `Result<T, E>`.ExamplesBoth `String` and `&str` implement `AsRef<str>`:Generic Impls`AsRef` auto-dereference if the inner type is a reference or a mutable reference (eg: `foo.as_ref()` will work the same if `foo` has type `&mut Foo` or `&&mut Foo`)"],["From","Construct `Self` via a conversion.**Note: this trait must not fail**. If the conversion can fail, use a dedicated method which return an `Option<T>` or a `Result<T, E>`.Examples`String` implements `From<&str>`:Generic impls`From<T> for U` implies `Into<U> for T` `from()` is reflexive, which means that `From<T> for T` is implemented"],["Into","A conversion that consumes `self`, which may or may not be expensive.**Note: this trait must not fail**. If the conversion can fail, use a dedicated method which return an `Option<T>` or a `Result<T, E>`.Library writer should not implement directly this trait, but should prefer the implementation of the `From` trait, which offer greater flexibility and provide the equivalent `Into` implementation for free, thanks to a blanket implementation in the standard library.Examples`String` implements `Into<Vec<u8>>`:Generic Impls`From<T> for U` implies `Into<U> for T` `into()` is reflexive, which means that `Into<T> for T` is implemented"]]});