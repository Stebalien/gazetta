<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `clap` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, clap">

    <title>clap - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'clap', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>clap</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/clap/lib.rs.html#1-685' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Command Line Argument Parser for Rust</p>

<p>It is a simple to use, efficient, and full featured library for parsing
command line arguments
and subcommands when writing console, or terminal applications.</p>

<h2 id='about' class='section-header'><a href='#about'>About</a></h2>
<p><code>clap</code> is used to parse <em>and validate</em> the string of command line arguments
provided by the
user at runtime. You provide the list of valid possibilities, and <code>clap</code>
handles the rest. This
means you focus on your <em>applications</em> functionality, and less on the
parsing and validating of
arguments.</p>

<p><code>clap</code> also provides the traditional version and help switches (or flags)
&#39;for free&#39; meaning
automatically with no configuration. It does this by checking list of valid
possibilities you
supplied and if you haven&#39;t them already (or only defined some of them),
<code>clap</code> will auto-
generate the applicable ones. If you are using subcommands, <code>clap</code> will
also auto-generate a
<code>help</code> subcommand for you in addition to the traditional flags.</p>

<p>Once <code>clap</code> parses the user provided string of arguments, it returns the
matches along with any
applicable values. If the user made an error or typo, <code>clap</code> informs them
of the mistake and
exits gracefully. Because of this, you can make reasonable assumptions in
your code about the
validity of the arguments.</p>

<h2 id='faq' class='section-header'><a href='#faq'>FAQ</a></h2>
<p>For a full FAQ and more in depth details, see
<a href="https://github.com/kbknapp/clap-rs/wiki/FAQ">the wiki page</a></p>

<h3 id='comparisons' class='section-header'><a href='#comparisons'>Comparisons</a></h3>
<p>First, let me say that these comparisons are highly subjective, and not
meant
in a critical or harsh manner. All the argument parsing libraries out there
(to include <code>clap</code>) have their own strengths and weaknesses. Sometimes it
just
comes down to personal taste when all other factors are equal. When in
doubt,
try them all and pick one that you enjoy :) There&#39;s plenty of room in the
Rust
community for multiple implementations!</p>

<h4 id='how-does-clap-compare-to-getopts' class='section-header'><a href='#how-does-clap-compare-to-getopts'>How does <code>clap</code> compare to <code>getopts</code>?</a></h4>
<p><a href="https://github.com/rust-lang-nursery/getopts">getopts</a> is a very basic,
fairly
minimalist argument parsing library. This isn&#39;t a bad thing, sometimes you
don&#39;t need tons of features, you just want to parse some simple arguments,
and
have some help text generated for you based on valid arguments you specify.
When using <code>getopts</code> you must manually implement most of the common features
(such as checking to display help messages, usage strings, etc.). If you
want a
highly custom argument parser, and don&#39;t mind writing most the argument
parser
yourself, <code>getopts</code> is an excellent base.</p>

<p>Due to it&#39;s lack of features, <code>getopts</code> also doesn&#39;t allocate much, or at
all.
This gives it somewhat of a performance boost. Although, as you start
implementing those features you need manually, that boost quickly
disappears.</p>

<p>Personally, I find many, many people that use <code>getopts</code> are manually
implementing features that <code>clap</code> has by default. Using <code>clap</code> simplifies
your
codebase allowing you to focus on your application, and not argument
parsing.</p>

<p>Reasons to use <code>getopts</code> instead of <code>clap</code></p>

<ul>
<li>You need a few allocations as possible, don&#39;t plan on implementing any
additional features</li>
<li>You want a highly custom argument parser, but want to use an established
parser as a base</li>
</ul>

<h4 id='how-does-clap-compare-to-docoptrs' class='section-header'><a href='#how-does-clap-compare-to-docoptrs'>How does <code>clap</code> compare to <code>docopt.rs</code>?</a></h4>
<p>I first want to say I&#39;m a big a fan of BurntSushi&#39;s work, the creator of
<a href="https://github.com/docopt/docopt.rs">Docopt.rs</a>. I aspire to produce the
quality of libraries that this man does! When it comes to comparing these
two
libraries they are very different. <code>docopt</code> tasks you with writing a help
message, and then it parsers that message for you to determine all valid
arguments and their use. Some people LOVE this, others not so much. If
you&#39;re
willing to write a detailed help message, it&#39;s nice that you can stick that
in
your program and have <code>docopt</code> do the rest. On the downside, it&#39;s somewhat
less
flexible than other options out there, and requires the help message change
if
you need to make changes.</p>

<p><code>docopt</code> is also excellent at translating arguments into Rust types
automatically. There is even a syntax extension which will do all this for
you,
ifou to manually translate from arguments to Rust types). To use
BurntSushi&#39;s
words, <code>docopt</code> is also somewhat of a black box. You get what you get, and
it&#39;s
hard to tweak implementation or customise your experience for your use case.</p>

<p>Because <code>docopt</code> is doing a ton of work to parse your help messages and
determine what you were trying to communicate as valid arguments, it&#39;s also
one
of the more heavy weight parsers performance-wise. For most applications
this
isn&#39;t a concern, but it&#39;s something to keep in mind.</p>

<p>Reasons to use <code>docopt</code> instead of <code>clap</code>
* You want automatic translation from arguments to Rust types, and are
using a
   nightly compiler
 * Performance isn&#39;t a concern
 * You don&#39;t have any complex relationships between arguments</p>

<h4 id='all-else-being-equal-what-are-some-reasons-to-use-clap' class='section-header'><a href='#all-else-being-equal-what-are-some-reasons-to-use-clap'>All else being equal, what are some reasons to use <code>clap</code>?</a></h4>
<p><code>clap</code> is fast, and as lightweight as possible while still giving all the
features you&#39;d expect from a modern argument parser. If you use <code>clap</code> when
just need some simple arguments parsed, you&#39;ll find it a walk in the park.
But
<code>clap</code> also makes it possible to represent extremely complex, and advanced
requirements, without too much thought. <code>clap</code> aims to be intuitive, easy to
use, and fully capable for wide variety use cases and needs.</p>

<h2 id='quick-examples' class='section-header'><a href='#quick-examples'>Quick Examples</a></h2>
<p>The following examples show a quick example of some of the very basic
functionality of <code>clap</code>.
For more advanced usage, such as requirements, exclusions, groups, multiple
values and
occurrences see the <a href="https://www.youtube.com/playlist?list=PLza5oFLQGTl0Bc_EU_pBNcX-rhVqDTRxv">video tutorials</a>,
<a href="http://kbknapp.github.io/clap-rs/clap/index.html">documentation</a>, or
<a href="https://github.com/kbknapp/clap-rs/tree/master/examples">examples/</a> directory of this crate&#39;s repository.</p>

<p><strong>NOTE:</strong> All these examples are functionally the same, but show three
different styles in
which to use <code>clap</code></p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// (Full example with detailed comments in examples/01a_quick_example.rs)</span>
<span class='comment'>//</span>
<span class='comment'>// This example demonstrates clap&#39;s &quot;usage strings&quot; method of creating</span>
<span class='comment'>// arguments which is less less verbose</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>clap</span>;
<span class='kw'>use</span> <span class='ident'>clap</span>::{<span class='ident'>Arg</span>, <span class='ident'>App</span>, <span class='ident'>SubCommand</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;myapp&quot;</span>)
        .<span class='ident'>version</span>(<span class='string'>&quot;1.0&quot;</span>)
        .<span class='ident'>author</span>(<span class='string'>&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)
        .<span class='ident'>about</span>(<span class='string'>&quot;Does awesome things&quot;</span>)
        .<span class='ident'>args_from_usage</span>(
            <span class='string'>&quot;-c --config=[CONFIG] &#39;Sets a custom config file&#39;
             &lt;INPUT&gt; &#39;Sets the input file to use&#39;
             [debug]... -d &#39;Sets the level of debugging information&#39;&quot;</span>)
        .<span class='ident'>subcommand</span>(<span class='ident'>SubCommand</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;test&quot;</span>)
            .<span class='ident'>about</span>(<span class='string'>&quot;controls testing features&quot;</span>)
            .<span class='ident'>version</span>(<span class='string'>&quot;1.3&quot;</span>)
            .<span class='ident'>author</span>(<span class='string'>&quot;Someone E. &lt;someone_else@other.com&gt;&quot;</span>)
            .<span class='ident'>arg_from_usage</span>(
                <span class='string'>&quot;-v --verbose &#39;Print test information verbosely&#39;&quot;</span>))
        .<span class='ident'>get_matches</span>();

    <span class='comment'>// Calling .unwrap() is safe here because &quot;INPUT&quot; is required (if</span>
    <span class='comment'>// &quot;INPUT&quot; wasn&#39;t required we could have used an &#39;if let&#39; to</span>
    <span class='comment'>// conditionally get the value)</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Using input file: {}&quot;</span>, <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;INPUT&quot;</span>).<span class='ident'>unwrap</span>());

    <span class='comment'>// Gets a value for config if supplied by user, or defaults to</span>
    <span class='comment'>// &quot;default.conf&quot;</span>
    <span class='kw'>let</span> <span class='ident'>config</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;CONFIG&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;default.conf&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Value for config: {}&quot;</span>, <span class='ident'>config</span>);

    <span class='comment'>// Vary the output based on how many times the user used the &quot;debug&quot;</span>
    <span class='comment'>// flag (i.e. &#39;myapp -d -d -d&#39; or &#39;myapp -ddd&#39; vs &#39;myapp -d&#39;)</span>
    <span class='kw'>match</span> <span class='ident'>matches</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;debug&quot;</span>) {
        <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is off&quot;</span>),
        <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is kind of on&quot;</span>),
        <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is on&quot;</span>),
        <span class='number'>3</span> <span class='op'>|</span> _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class='comment'>// You can information about subcommands by requesting their matches by</span>
    <span class='comment'>// name (as below), requesting just the name used, or both at the same</span>
    <span class='comment'>// time</span>
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>matches</span>) <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>subcommand_matches</span>(<span class='string'>&quot;test&quot;</span>) {
        <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbose&quot;</span>) {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing verbosely...&quot;</span>);
        } <span class='kw'>else</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing normally...&quot;</span>);
        }
    }

    <span class='comment'>// more program logic goes here...</span>
}</pre>

<p>The following example is functionally the same as the one above, but this
method allows more
advanced configuration options (not shown in this small example), or even
dynamically
generating arguments when desired. Both methods can be used together to get
the best of both
worlds (see the documentation, <a href="https://github.com/kbknapp/clap-rs/tree/master/examples">examples/</a>, or video tutorials).</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// (Full example with detailed comments in examples/01b_quick_example.rs)</span>
<span class='comment'>//</span>
<span class='comment'>// This example demonstrates clap&#39;s full &#39;builder pattern&#39; style of</span>
<span class='comment'>// creating arguments which is</span>
<span class='comment'>// more verbose, but allows easier editing, and at times more advanced</span>
<span class='comment'>// options, or the possibility</span>
<span class='comment'>// to generate arguments dynamically.</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>clap</span>;
<span class='kw'>use</span> <span class='ident'>clap</span>::{<span class='ident'>Arg</span>, <span class='ident'>App</span>, <span class='ident'>SubCommand</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;myapp&quot;</span>)
        .<span class='ident'>version</span>(<span class='string'>&quot;1.0&quot;</span>)
        .<span class='ident'>author</span>(<span class='string'>&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)
        .<span class='ident'>about</span>(<span class='string'>&quot;Does awesome things&quot;</span>)
        .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;CONFIG&quot;</span>)
            .<span class='ident'>short</span>(<span class='string'>&quot;c&quot;</span>)
            .<span class='ident'>long</span>(<span class='string'>&quot;config&quot;</span>)
            .<span class='ident'>help</span>(<span class='string'>&quot;Sets a custom config file&quot;</span>)
            .<span class='ident'>takes_value</span>(<span class='boolval'>true</span>))
        .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;INPUT&quot;</span>)
            .<span class='ident'>help</span>(<span class='string'>&quot;Sets the input file to use&quot;</span>)
            .<span class='ident'>required</span>(<span class='boolval'>true</span>)
            .<span class='ident'>index</span>(<span class='number'>1</span>))
        .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;debug&quot;</span>)
            .<span class='ident'>short</span>(<span class='string'>&quot;d&quot;</span>)
            .<span class='ident'>multiple</span>(<span class='boolval'>true</span>)
            .<span class='ident'>help</span>(<span class='string'>&quot;Sets the level of debugging information&quot;</span>))
        .<span class='ident'>subcommand</span>(<span class='ident'>SubCommand</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;test&quot;</span>)
            .<span class='ident'>about</span>(<span class='string'>&quot;controls testing features&quot;</span>)
            .<span class='ident'>version</span>(<span class='string'>&quot;1.3&quot;</span>)
            .<span class='ident'>author</span>(<span class='string'>&quot;Someone E. &lt;someone_else@other.com&gt;&quot;</span>)
            .<span class='ident'>arg</span>(<span class='ident'>Arg</span>::<span class='ident'>with_name</span>(<span class='string'>&quot;verbose&quot;</span>)
                .<span class='ident'>short</span>(<span class='string'>&quot;v&quot;</span>)
                .<span class='ident'>help</span>(<span class='string'>&quot;print test information verbosely&quot;</span>)))
        .<span class='ident'>get_matches</span>();

    <span class='comment'>// Calling .unwrap() is safe here because &quot;INPUT&quot; is required (if</span>
    <span class='comment'>// &quot;INPUT&quot; wasn&#39;t required we could have used an &#39;if let&#39; to</span>
    <span class='comment'>// conditionally get the value)</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Using input file: {}&quot;</span>, <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;INPUT&quot;</span>).<span class='ident'>unwrap</span>());

    <span class='comment'>// Gets a value for config if supplied by user, or defaults to</span>
    <span class='comment'>// &quot;default.conf&quot;</span>
    <span class='kw'>let</span> <span class='ident'>config</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;CONFIG&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;default.conf&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Value for config: {}&quot;</span>, <span class='ident'>config</span>);

    <span class='comment'>// Vary the output based on how many times the user used the &quot;debug&quot;</span>
    <span class='comment'>// flag (i.e. &#39;myapp -d -d -d&#39; or &#39;myapp -ddd&#39; vs &#39;myapp -d&#39;)</span>
    <span class='kw'>match</span> <span class='ident'>matches</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;debug&quot;</span>) {
        <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is off&quot;</span>),
        <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is kind of on&quot;</span>),
        <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is on&quot;</span>),
        <span class='number'>3</span> <span class='op'>|</span> _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class='comment'>// You can information about subcommands by requesting their matches by</span>
    <span class='comment'>// name (as below), requesting just the name used, or both at the same</span>
    <span class='comment'>// time</span>
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>matches</span>) <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>subcommand_matches</span>(<span class='string'>&quot;test&quot;</span>) {
        <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbose&quot;</span>) {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing verbosely...&quot;</span>);
        } <span class='kw'>else</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing normally...&quot;</span>);
        }
    }

    <span class='comment'>// more program logic goes here...</span>
}</pre>

<p>The following combines the previous two examples by using the simplicity of
the <code>from_usage</code>
methods and the performance of the Builder Pattern.</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// (Full example with detailed comments in examples/01c_quick_example.rs)</span>
<span class='comment'>//</span>
<span class='comment'>// This example demonstrates clap&#39;s &quot;usage strings&quot; method of creating</span>
<span class='comment'>// arguments which is less verbose</span>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>clap</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='macro'>clap_app</span><span class='macro'>!</span>(<span class='ident'>myapp</span> <span class='op'>=&gt;</span>
        (<span class='ident'>version</span>: <span class='string'>&quot;1.0&quot;</span>)
        (<span class='ident'>author</span>: <span class='string'>&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)
        (<span class='ident'>about</span>: <span class='string'>&quot;Does awesome things&quot;</span>)
        (<span class='kw-2'>@</span><span class='ident'>arg</span> <span class='ident'>CONFIG</span>: <span class='op'>-</span><span class='ident'>c</span> <span class='op'>-</span><span class='op'>-</span><span class='ident'>config</span> <span class='op'>+</span><span class='ident'>takes_value</span> <span class='string'>&quot;Sets a custom config file&quot;</span>)
        (<span class='kw-2'>@</span><span class='ident'>arg</span> <span class='ident'>INPUT</span>: <span class='op'>+</span><span class='ident'>required</span> <span class='string'>&quot;Sets the input file to use&quot;</span>)
        (<span class='kw-2'>@</span><span class='ident'>arg</span> <span class='ident'>debug</span>: <span class='op'>-</span><span class='ident'>d</span> ... <span class='string'>&quot;Sets the level of debugging information&quot;</span>)
        (<span class='kw-2'>@</span><span class='ident'>subcommand</span> <span class='ident'>test</span> <span class='op'>=&gt;</span>
            (<span class='ident'>about</span>: <span class='string'>&quot;controls testing features&quot;</span>)
            (<span class='ident'>version</span>: <span class='string'>&quot;1.3&quot;</span>)
            (<span class='ident'>author</span>: <span class='string'>&quot;Someone E. &lt;someone_else@other.com&gt;&quot;</span>)
            (<span class='kw-2'>@</span><span class='ident'>arg</span> <span class='ident'>verbose</span>: <span class='op'>-</span><span class='ident'>v</span> <span class='op'>-</span><span class='op'>-</span><span class='ident'>verbose</span> <span class='string'>&quot;Print test information verbosely&quot;</span>)
        )
    ).<span class='ident'>get_matches</span>();

    <span class='comment'>// Calling .unwrap() is safe here because &quot;INPUT&quot; is required (if</span>
    <span class='comment'>// &quot;INPUT&quot; wasn&#39;t required we could have used an &#39;if let&#39; to</span>
    <span class='comment'>// conditionally get the value)</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Using input file: {}&quot;</span>, <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;INPUT&quot;</span>).<span class='ident'>unwrap</span>());

    <span class='comment'>// Gets a value for config if supplied by user, or defaults to</span>
    <span class='comment'>// &quot;default.conf&quot;</span>
    <span class='kw'>let</span> <span class='ident'>config</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;CONFIG&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;default.conf&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Value for config: {}&quot;</span>, <span class='ident'>config</span>);

    <span class='comment'>// Vary the output based on how many times the user used the &quot;debug&quot;</span>
    <span class='comment'>// flag (i.e. &#39;myapp -d -d -d&#39; or &#39;myapp -ddd&#39; vs &#39;myapp -d&#39;)</span>
    <span class='kw'>match</span> <span class='ident'>matches</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;debug&quot;</span>) {
        <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is off&quot;</span>),
        <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is kind of on&quot;</span>),
        <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is on&quot;</span>),
        <span class='number'>3</span> <span class='op'>|</span> _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class='comment'>// You can information about subcommands by requesting their matches by</span>
    <span class='comment'>// name (as below), requesting just the name used, or both at the same</span>
    <span class='comment'>// time</span>
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>matches</span>) <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>subcommand_matches</span>(<span class='string'>&quot;test&quot;</span>) {
        <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbose&quot;</span>) {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing verbosely...&quot;</span>);
        } <span class='kw'>else</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing normally...&quot;</span>);
        }
    }

    <span class='comment'>// more program logic goes here...</span>
}</pre>

<p>This final method shows how you can use a YAML file to build your CLI and
keep your Rust source
tidy. First, create the <code>cli.yml</code> file to hold your CLI options, but it
could be called
anything we like (we&#39;ll use the same both examples above to keep it
functionally equivalent):</p>

<pre><code class="language-yaml">name: myapp
version: 1.0
author: Kevin K. &lt;kbknapp@gmail.com&gt;
about: Does awesome things
args:
    - CONFIG:
        short: c
        long: config
        help: Sets a custom config file
        takes_value: true
    - INPUT:
        help: Sets the input file to use
        required: true
        index: 1
    - debug:
        short: d
        multiple: true
        help: Sets the level of debugging information
subcommands:
    - test:
        about: controls testing features
        version: 1.3
        author: Someone E. &lt;someone_else@other.com&gt;
        args:
            - verbose:
                short: v
                help: print test information verbosely
</code></pre>

<p>Now we create our <code>main.rs</code> file just like we would have with the previous
two examples:</p>
<pre class='rust rust-example-rendered'>
<span class='comment'>// (Full example with detailed comments in examples/17_yaml.rs)</span>
<span class='comment'>//</span>
<span class='comment'>// This example demonstrates clap&#39;s building from YAML style of creating</span>
<span class='ident'>arguments</span> <span class='ident'>which</span> <span class='ident'>is</span> <span class='ident'>far</span>
<span class='comment'>// more clean, but takes a very small performance hit compared to the other</span>
<span class='ident'>two</span> <span class='ident'>methods</span>.
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>clap</span>;
<span class='kw'>use</span> <span class='ident'>clap</span>::<span class='ident'>App</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
<span class='comment'>// The YAML file is found relative to the current file, similar to how</span>
<span class='ident'>modules</span> <span class='ident'>are</span> <span class='ident'>found</span>
    <span class='kw'>let</span> <span class='ident'>yaml</span> <span class='op'>=</span> <span class='macro'>load_yaml</span><span class='macro'>!</span>(<span class='string'>&quot;cli.yml&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>from_yaml</span>(<span class='ident'>yaml</span>).<span class='ident'>get_matches</span>();

<span class='comment'>// Calling .unwrap() is safe here because &quot;INPUT&quot; is required (if</span>
<span class='string'>&quot;INPUT&quot;</span> <span class='ident'>wasn</span><span class='lifetime'>&#39;t</span>
<span class='comment'>// required we could have used an &#39;if let&#39; to conditionally get the</span>
<span class='ident'>value</span>)
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Using input file: {}&quot;</span>, <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;INPUT&quot;</span>).<span class='ident'>unwrap</span>());

<span class='comment'>// Gets a value for config if supplied by user, or defaults to</span>
<span class='string'>&quot;default.conf&quot;</span>
    <span class='kw'>let</span> <span class='ident'>config</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>value_of</span>(<span class='string'>&quot;CONFIG&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;default.conf&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Value for config: {}&quot;</span>, <span class='ident'>config</span>);

<span class='comment'>// Vary the output based on how many times the user used the &quot;debug&quot;</span>
<span class='ident'>flag</span>
    <span class='comment'>// (i.e. &#39;myapp -d -d -d&#39; or &#39;myapp -ddd&#39; vs &#39;myapp -d&#39;</span>
    <span class='kw'>match</span> <span class='ident'>matches</span>.<span class='ident'>occurrences_of</span>(<span class='string'>&quot;debug&quot;</span>) {
        <span class='number'>0</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is off&quot;</span>),
        <span class='number'>1</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is kind of on&quot;</span>),
        <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Debug mode is on&quot;</span>),
        <span class='number'>3</span> <span class='op'>|</span> _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Don&#39;t be crazy&quot;</span>),
    }

<span class='comment'>// You can information about subcommands by requesting their matches by</span>
<span class='ident'>name</span>
    <span class='comment'>// (as below), requesting just the name used, or both at the same time</span>
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Some</span>(<span class='ident'>matches</span>) <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>subcommand_matches</span>(<span class='string'>&quot;test&quot;</span>) {
        <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>is_present</span>(<span class='string'>&quot;verbose&quot;</span>) {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing verbosely...&quot;</span>);
        } <span class='kw'>else</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Printing normally...&quot;</span>);
        }
    }

    <span class='comment'>// more program logic goes here...</span>
}</pre>

<p>If you were to compile any of the above programs and run them with the flag
<code>--help</code> or <code>-h</code>
(or <code>help</code> subcommand, since we defined <code>test</code> as a subcommand) the
following would be output</p>

<p><strong>NOTE</strong>: The YAML option requires adding a special <code>features</code> flag when
compiling <code>clap</code>
because it is not compiled by default since it takes additional
dependencies that some people
may not need. Simply change your <code>clap = &quot;1&quot;</code> to <code>clap = {version = &quot;1&quot;, features = [&quot;yaml&quot;]}</code>
in your <code>Cargo.toml</code> to use the YAML version.</p>

<pre><code class="language-text">$ myapp --help
myapp 1.0
Kevin K. &lt;kbknapp@gmail.com&gt;
Does awesome things

USAGE:
    MyApp [FLAGS] [OPTIONS] &lt;INPUT&gt; [SUBCOMMAND]

FLAGS:
    -d               Turn debugging information on
    -h, --help       Prints this message
    -V, --version    Prints version information

OPTIONS:
    -c, --config &lt;CONFIG&gt;    Sets a custom config file

ARGS:
    INPUT    The input file to use

SUBCOMMANDS:
    help    Prints this message
    test    Controls testing features
</code></pre>

<p><strong>NOTE:</strong> You could also run <code>myapp test --help</code> to see similar output and
options for the
<code>test</code> subcommand.</p>

<h2 id='try-it' class='section-header'><a href='#try-it'>Try it!</a></h2>
<h3 id='pre-built-test' class='section-header'><a href='#pre-built-test'>Pre-Built Test</a></h3>
<p>To try out the pre-built example, use the following steps:</p>

<ul>
<li>Clone the repo <code>$ git clone https://github.com/kbknapp/clap-rs &amp;&amp; cd clap-rs/clap-tests</code></li>
<li>Compile the example <code>$ cargo build --release</code></li>
<li>Run the help info <code>$ ./target/release/claptests --help</code></li>
<li>Play with the arguments!</li>
</ul>

<h3 id='byob-build-your-own-binary' class='section-header'><a href='#byob-build-your-own-binary'>BYOB (Build Your Own Binary)</a></h3>
<p>To test out <code>clap</code>&#39;s default auto-generated help/version follow these steps:
* Create a new cargo project <code>$ cargo new fake --bin &amp;&amp; cd fake</code>
* Add <code>clap</code> to your <code>Cargo.toml</code>
*
<code>toml [dependencies] clap = &quot;1&quot;</code></p>

<ul>
<li>Add the following to your <code>src/main.rs</code></li>
</ul>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>clap</span>;
<span class='kw'>use</span> <span class='ident'>clap</span>::<span class='ident'>App</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
  <span class='kw'>let</span> _ <span class='op'>=</span> <span class='ident'>App</span>::<span class='ident'>new</span>(<span class='string'>&quot;fake&quot;</span>).<span class='ident'>version</span>(<span class='string'>&quot;v1.0-beta&quot;</span>).<span class='ident'>get_matches</span>();
}</pre>

<ul>
<li>Build your program <code>$ cargo build --release</code></li>
<li>Run w/ help or version <code>$ ./target/release/fake --help</code> or <code>$ ./target/release/fake --version</code></li>
</ul>

<h2 id='usage' class='section-header'><a href='#usage'>Usage</a></h2>
<p>For full usage, add <code>clap</code> as a dependency in your <code>Cargo.toml</code> file to use
from crates.io:</p>

<pre><code class="language-toml"> [dependencies]
 clap = &quot;1&quot;
</code></pre>

<p>Or track the latest on the master branch at github:</p>

<pre><code class="language-toml">[dependencies.clap]
git = &quot;https://github.com/kbknapp/clap-rs.git&quot;
</code></pre>

<p>Add <code>extern crate clap;</code> to your crate root.</p>

<p>Define a list of valid arguments for your program (see the
<a href="http://kbknapp.github.io/clap-rs/clap/index.html">documentation</a> or
<a href="https://github.com/kbknapp/clap-rs/tree/master/examples">examples/</a> directory of this repo)</p>

<p>Then run <code>cargo build</code> or <code>cargo update &amp;&amp; cargo build</code> for your project.</p>

<h3 id='optional-dependencies--features' class='section-header'><a href='#optional-dependencies--features'>Optional Dependencies / Features</a></h3>
<p>If you&#39;d like to keep your dependency list to <strong>only</strong> <code>clap</code>, you can
disable any features
that require an additional dependency. To do this, add this to your
<code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[dependencies.clap]
version = &quot;1&quot;
default-features = false
</code></pre>

<p>You can also selectively enable only the features you&#39;d like to include, by
adding:</p>

<pre><code class="language-toml">[dependencies.clap]
version = &quot;1&quot;
default-features = false

# Cherry-pick the features you&#39;d like to use
features = [ &quot;suggestions&quot;, &quot;color&quot; ]
</code></pre>

<p>The following is a list of optional <code>clap</code> features:</p>

<ul>
<li><strong>&quot;suggestions&quot;</strong>: Turns on the <code>Did you mean &#39;--myoption&#39; ?</code> feature for
when users make
typos.</li>
<li><strong>&quot;color&quot;</strong>: Turns on red error messages. This feature only works on
non-Windows OSs.</li>
<li><strong>&quot;lints&quot;</strong>: This is <strong>not</strong> included by default and should only be used
while developing to
run basic lints against changes. This can only be used on Rust nightly.</li>
</ul>

<h3 id='dependencies-tree' class='section-header'><a href='#dependencies-tree'>Dependencies Tree</a></h3>
<p>The following graphic depicts <code>clap</code>s dependency graph.</p>

<ul>
<li><strong>Dashed</strong> Line: Optional dependency</li>
<li><strong>Red</strong> Color: <strong>NOT</strong> included by default (must use cargo <code>features</code> to
enable)</li>
</ul>

<p><img src="https://raw.githubusercontent.%0Acom/kbknapp/clap-rs/master/clap.png" alt="clap dependencies"></p>

<h3 id='more-information' class='section-header'><a href='#more-information'>More Information</a></h3>
<p>You can find complete documentation on the <a href="http://kbknapp.github.io/clap-rs/clap/index.html">github-pages site</a> for
this project.</p>

<p>You can also find usage examples in the <a href="https://github.com/kbknapp/clap-rs/tree/master/examples">examples/</a> directory of
this repo.</p>

<h4 id='video-tutorials' class='section-header'><a href='#video-tutorials'>Video Tutorials</a></h4>
<p>There&#39;s also the video tutorial series [Argument Parsing with Rust]<a href="https://www.youtube.com/playlist?list=PLza5oFLQGTl0Bc_EU_pBNcX-rhVqDTRxv">video
tutorials</a> that I&#39;ve
been working on.</p>

<p><em>Note</em>: Two new videos have just been added (<a href="https://youtu.be/xc6VdedFrG0">08 From
Usage</a>, and
<a href="https://youtu.be/mZn3C1DnD90">09 Typed Values</a>), if you&#39;re already
familiar with <code>clap</code> but
want to know more about these two details you can check out those videos
without watching the
previous few.</p>

<p><em>Note</em>: Apologies for the resolution of the first video, it will be updated
to a better
resolution soon. The other videos have a proper resolution.</p>

<h3 id='running-the-tests' class='section-header'><a href='#running-the-tests'>Running the tests</a></h3>
<p>If contributing, you can run the tests as follows (assuming you&#39;re in the
<code>clap-rs</code> directory)</p>

<pre><code class="language-sh">cargo test --features yaml &amp;&amp; make -C clap-tests test
</code></pre>

<h2 id='license' class='section-header'><a href='#license'>License</a></h2>
<p><code>clap</code> is licensed under the MIT license. Please read the
<a href="https://raw.githubusercontent.com/kbknapp/clap-rs/master/LICENSE-MIT">LICENSE-MIT</a>
file in
this repository for more information.</p>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.arg_enum!.html'
                               title='clap::arg_enum!'>arg_enum!</a></td>
                        <td class='docblock short'>
                             <p>Convenience macro to generate more complete enums with variants to be used as a type when
parsing arguments. This enum also provides a <code>variants()</code> function which can be used to retrieve a
<code>Vec&lt;&amp;&#39;static str&gt;</code> of the variant names.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.clap_app!.html'
                               title='clap::clap_app!'>clap_app!</a></td>
                        <td class='docblock short'>
                             <p>App, Arg, SubCommand and Group builder macro (Usage-string like input)</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.crate_version!.html'
                               title='clap::crate_version!'>crate_version!</a></td>
                        <td class='docblock short'>
                             <p>Allows you pull the version for an from your Cargo.toml as MAJOR.MINOR.PATCH_PKGVERSION_PRE</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.simple_enum!.html'
                               title='clap::simple_enum!'>simple_enum!</a></td>
                        <td class='docblock short'>
                             <p>Convenience macro generated a simple enum with variants to be used as a type when parsing
arguments. This enum also provides a <code>variants()</code> function which can be used to retrieve a
<code>Vec&lt;&amp;&#39;static str&gt;</code> of the variant names.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.value_t!.html'
                               title='clap::value_t!'>value_t!</a></td>
                        <td class='docblock short'>
                             <p>Convenience macro getting a typed value <code>T</code> where <code>T</code> implements <code>std::str::FromStr</code>
This macro returns a <code>Result&lt;T,String&gt;</code> which allows you as the developer to decide
what you&#39;d like to do on a failed parse. There are two types of errors, parse failures
and those where the argument wasn&#39;t present (such as a non-required argument).</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='macro' href='macro.value_t_or_exit!.html'
                               title='clap::value_t_or_exit!'>value_t_or_exit!</a></td>
                        <td class='docblock short'>
                             <p>Convenience macro getting a typed value <code>T</code> where <code>T</code> implements <code>std::str::FromStr</code>
This macro returns a <code>T</code> or <code>Vec&lt;T&gt;</code> or exits with a usage string upon failure. This
removes some of the boiler plate to handle failures from value_t! above.</p>

                        </td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.App.html'
                               title='clap::App'>App</a></td>
                        <td class='docblock short'>
                             <p>Used to create a representation of a command line program and all possible command line
arguments.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Arg.html'
                               title='clap::Arg'>Arg</a></td>
                        <td class='docblock short'>
                             <p>The abstract representation of a command line argument used by the consumer of the library.
Used to set all the options and relationships that define a valid argument for the program.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.ArgGroup.html'
                               title='clap::ArgGroup'>ArgGroup</a></td>
                        <td class='docblock short'>
                             <p><code>ArgGroup</code>s are a family of related arguments and way for you to say, &quot;Any of these arguments&quot;.
By placing arguments in a logical group, you can make easier requirement and exclusion rules
instead of having to list each individually, or when you want a rule to apply &quot;any but not all&quot;
arguments.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.ArgMatches.html'
                               title='clap::ArgMatches'>ArgMatches</a></td>
                        <td class='docblock short'>
                             <p>Used to get information about the arguments that where supplied to the program at runtime by
the user. To get a new instance of this struct you use <code>.get_matches()</code> of the <code>App</code> struct.</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.ClapError.html'
                               title='clap::ClapError'>ClapError</a></td>
                        <td class='docblock short'>
                             <p>Command line argument parser error</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.SubCommand.html'
                               title='clap::SubCommand'>SubCommand</a></td>
                        <td class='docblock short'>
                             <p>The abstract representation of a command line subcommand used by the consumer of the library.</p>

                        </td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.AppSettings.html'
                               title='clap::AppSettings'>AppSettings</a></td>
                        <td class='docblock short'>
                             <p>Application level settings, which affect how <code>App</code> operates</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.ClapErrorType.html'
                               title='clap::ClapErrorType'>ClapErrorType</a></td>
                        <td class='docblock short'>
                             <p>Command line argument parser error types</p>

                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.Format.html'
                               title='clap::Format'>Format</a></td>
                        <td class='docblock short'>
                             <p>Defines styles for different types of error messages. Defaults to Error=Red, Warning=Yellow,
and Good=Green</p>

                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "clap";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>