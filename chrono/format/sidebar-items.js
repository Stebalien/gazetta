initSidebarItems({"enum":[["Fixed","Fixed-format item types.They have their own rules of formatting and parsing. Otherwise noted, they print in the specified cases but parse case-insensitively."],["Item","A single formatting item. This is used for both formatting and parsing."],["Numeric","Numeric item types. They have associated formatting width (FW) and parsing width (PW).The **formatting width** is the minimal width to be formatted. If the number is too short, and the padding is not `Pad::None`, then it is left-padded. If the number is too long or (in some cases) negative, it is printed as is.The **parsing width** is the maximal width to be scanned. The parser only tries to consume from one to given number of digits (greedily).  It also trims the preceding whitespaces if any. It cannot parse the negative number, so some date and time cannot be formatted then parsed with the same formatting items."],["Pad","Padding characters for numeric items."]],"fn":[["format","Tries to format given arguments with given formatting items. Internally used by `DelayedFormat`."],["parse","Tries to parse given string into `parsed` with given formatting items. Returns `Ok` when the entire string has been parsed (otherwise `parsed` should not be used). There should be no trailing string after parsing; use a stray `Item::Space` to trim whitespaces.This particular date and time parser is:Greedy. It will consume the longest possible prefix. For example, `April` is always consumed entirely when the long month name is requested; it equally accepts `Apr`, but prefers the longer prefix in this case. Padding-agnostic (for numeric items). The `Pad` field is completely ignored, so one can prepend any number of whitespace then any number of zeroes before numbers. (Still) obeying the intrinsic parsing width. This allows, for example, parsing `HHMMSS`."]],"mod":[["parsed","A collection of parsed date and time items. They can be constructed incrementally while being checked for consistency."],["strftime","`strftime`/`strptime`-inspired date and time formatting syntax.SpecifiersThe following specifiers are available both to formatting and parsing.It is possible to override the default padding behavior of numeric specifiers `%?`. This is not allowed for other specifiers and will result in the `BAD_FORMAT` error.Notes:`%Y`: Negative years are allowed in formatting but not in parsing.`%C`, `%y`: This is floor division, so 100 BCE (year number -99) will print `-1` and `99` respectively.`%U`: Week 1 starts with the first Sunday in that year. It is possible to have week 0 for days before the first Sunday.`%G`, `%g`, `%V`: Week 1 is the first week with at least 4 days in that year. Week 0 does not exist, so this should be used with `%G` or `%g`.`%S`: It accounts for leap seconds, so `60` is possible.`%+`: This one is close to, but not identical to, `%Y-%m-%dT%H:%M:%S%.f%z`. The main differences are a colon in `%z`.`%s`: This is not padded and can be negative. For the purpose of Chrono, it only accounts for non-leap seconds so it slightly differs from ISO C `strftime` behavior.`%f`, `%.f`, `%.3f`, `%.6f`, `%.9f`:The default `%f` is right-aligned and always zero-padded to 9 digits for the compatibility with glibc and others, so it always counts the number of nanoseconds since the last whole second. E.g. 7ms after the last second will print `007000000`, and parsing `7000000` will yield the same.The variant `%.f` is left-aligned and print 0, 3, 6 or 9 fractional digits according to the precision. E.g. 70ms after the last second under `%.f` will print `.070` (note: not `.07`), and parsing `.07`, `.070000` etc. will yield the same. Note that they can print or read nothing if the fractional part is zero or the next character is not `.`.The variant `%.3f`, `%.3f` and `%.3f` are left-aligned and print 3, 6 or 9 fractional digits according to the number preceding `f`. E.g. 70ms after the last second under `%.3f` will print `.070` (note: not `.07`), and parsing `.07`, `.070000` etc. will yield the same. Note that they can read nothing if the fractional part is zero or the next character is not `.` however will print with the specified length."]],"struct":[["DelayedFormat","A *temporary* object which can be used as an argument to `format!` or others. This is normally constructed via `format` methods of each date and time type."],["ParseError","An error from the `parse` function."]],"type":[["ParseResult","Same to `Result<T, ParseError>`."]]});